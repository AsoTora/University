<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Лабораторная работа №5</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head>
<body>


<div class="title">ЛАБОРАТОРНАЯ РАБОТА № 5</div>

<div class="title">ПРОИЗВОДНЫЕ КЛАССЫ И ИЕРАРХИИ КЛАССОВ</div>

<center>[<a href="lab4.html">Предыдущая работа</a>][<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="lab6.html">Следующая работа</a>]</center>

<br>
<br>
<div class="title">
<a name="0"></a>Оглавление</div>

<ol type="1">

<li>
<a href="#1">Цель работы</a>
</li>

<li>
<a href="#2">Производные классы</a>
</li>

<ul>

<li>
<a href="#2_1">Понятие производного класса</a>
</li>

<li>
<a href="#2_2">Функции-элементы</a>
</li>

<li>
<a href="#2_3">Конструкторы и деструкторы</a>
</li>

<li>
<a href="#2_4">Копирование</a>
</li>

<li>
<a href="#2_5">Виртуальные функции</a>
</li>

<li>
<a href="#2_6">Абстрактные классы</a>
</li>

</ul>

<li>
<a href="#3">Иерархии классов</a>
</li>

<ul>

<li>
<a href="#3_1">Иерархии классов и абстрактные классы</a>
</li>

<li>
<a href="#3_2">Управление доступом</a>
</li>

<li>
<a href="#3_3">Множественное наследование и разрешение неоднозначности</a>
</li>

<li>
<a href="#3_4">Виртуальные базовые классы</a>
</li>

</ul>

<li>
<a href="#4">Индивидуальные задания</a>
</li>

</ol>


<br>
<br>
<div class="title">
<a name="1"></a>1.	ЦЕЛЬ РАБОТЫ</div>

<ol type="1">

<li>Изучение базовых средств языка С++ для выражения иерархических отношений между классами.</li> 

<li>Изучение основных правил наследования классов в языке С++.</li>

<li>Использование абстрактных классов как средства для последовательного построения классов.</li>

</ol>


<br>
<br>
<div class="title">
<a name="2"></a>2.	ПРОИЗВОДНЫЕ КЛАССЫ</div>


<br>
<br>
<div class="header">
<a name="2_1"></a>2.1.	Понятие производного класса</div>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Производный класс &ndash; расширение существующих классов,  называемых в этом случае <i>базовыми</i>. Любой класс, не являющийся объединением (<i>union</i>), может служить базовым. В отличие от вложенных классов, производный класс определяется независимо от его базовых классов, включая и этап компиляции.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Допустим, создается программа, обрабатывающая информацию о сотрудниках (<i>employee</i>) фирмы. Для такой программы может понадобиться следующий класс:</p>



<pre>
<div class="code">
class Employee
{
  string first_name, family_name;
  char middle_initial;
  Date hiring_date;
  Short department;
};
</div>
</pre>

Затем можно определить менеджера:

<pre>
<div class="code">
class Manager : public Employee
{
  Employee* group; // подчиненные
  short level;
  // ...
}
</div>
</pre>



<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Класс <i>Manager</i> является <i>производным</i> от <i>Employee</i>, а <i>Employee</i> является <i>базовым</i> классом для <i>Manager</i>. Класс <i>Manager</i> кроме своих собственных элементов (<i>group, level</i> и т. д.) содержит элементы класса <i>Employee</i> (<i>first_name, department</i> и т. д.). Часто говорят, что производный класс наследует свойства базового, поэтому их отношения нередко называют <i>наследованием</i>. Базовый класс иногда называют <i>суперклассом</i>, а производный &ndash; <i>подклассом</i>.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 С объектом производного класса можно обращаться как с объектом базового класса при обращении к нему при помощи указателей и ссылок. Обратное неверно. Например:</p>


<pre>
<div class="code">
void f(Manager mm, Employee ee)
{
  Employee* pe = &amp;mm; // правильно: каждый Manager
                      // является Employee
  Manager* pm = &amp;ee;  // ошибка: не каждый Employee
                      // является Manager
  pm-&gt;level = 2;      // катастрофа: у переменной pm
                      // нет level
  pm = static_cast&lt;Manager*&gt;(pe); // грубая сила: pe
                                  // указывает на переменную
                                  // mm класса Manager
  pm-&gt;level = 2;      // прекрасно: pm указывает на
                      // переменную mm класса Manager,
                      // у которой есть level
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Другими словами, если производный класс <i>Derived</i> имеет в качестве базового открытого класса <i>Base</i>, то <i>Derived*</i> может быть присвоен переменной типа <i>Base*</i> без явного преобразования типа. Обратное преобразование из <i>Base*</i> в <i>Derived*</i> должно быть явным. Использование оператора <i>static_cast</i> обсуждается в следующих работах.</p>



<br>
<br>
<div class="header">
<a name="2_2"></a>2.2.	Функции-элементы</div>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Функции-элементы производного класса могут пользоваться открытыми и защищенными элементами базового класса так, как будто они объявлены в самом производном классе. Например:</p> 



<pre>
<div class="code">
class Employee
{
  string first_name, family_name;
  // ...
public:
  string full_name() const
  { return first_name+&rsquo; &rsquo;+middle_initial+&rsquo; &rsquo;+family_name; }
};

class Manager : public Employee
{
  // ...
public:
  void print() const;
}

void Manager::print() const
{
  cout &lt;&lt; &rdquo;Имя &rdquo; &lt;&lt; full_name() &lt;&lt; &rsquo;\n&rsquo;;
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Однако производный класс не может использовать закрытые имена базового класса:</p>


<pre>
<div class="code">
void Manager::print() const
{
  cout &lt;&lt; &rdquo;Имя &rdquo; &lt;&lt; first_name() &lt;&lt; &rsquo;\n&rsquo;; // ошибка
}
</div>
</pre>



<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Вторая версия <i>Manager::print()</i> не будет откомпилирована. Элементы производного класса не имеют специального разрешения на доступ к закрытым элементам базового класса.</p>



<br>
<br>
<div class="header">
<a name="2_3"></a>2.3.	Конструкторы и деструкторы</div>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Некоторые производные классы нуждаются в конструкторах. Если базовый класс имеет конструктор, он должен быть вызван, и если конструктор имеет аргументы, они должны быть предоставлены. Например:</p> 


<pre>
<div class="code">
class Employee
{
  string first_name, family_name;
  short department;
  // ...
public:
  Employee(const string&amp; n, int d);
};

class Manager : public Employee
{
  // ...
  short level;
public:
  Manager(const string&amp; n, int d, int lvl);
};

Employee::Employee(const string&amp; n, int d):
  first_name(n), department(d) // инициализация элементов
{
  // ...
}
Manager::Manager(const string&amp; n, int d, int lvl):
  Employee(n, d), level(lvl)
{
 // ...
}
</div>
</pre>

	
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Конструктор производного класса может указать инициализаторы для своих элементов и элементов базового класса; он не может непосредственно инициализировать элементы базового класса. Например:	</p>


<pre>
<div class="code">
Manager::Manager(const string&amp; n, int d, int lvl):
  first_name(n), // ошибка: first_name нет в Manager
  department(d), // ошибка: department нет в Manager
  level(lvl)
{ /* ... */ }
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Это определение содержит три ошибки: не вызывается конструктор <i>Employee()</i> и дважды осуществляется попытка инициализации элементов <i>Employee</i> непосредственно.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Если список конструктора производного класса не содержит операций вызова конструкторов некоторых базовых классов, то автоматически будут вызываться конструкторы таких классов по умолчанию. </p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Объекты класса создаются снизу-вверх: сначала базовый класс, потом элементы и затем сам производный класс. Они уничтожаются в противоположном порядке: сначала производный класс, элементы, а затем базовый класс.</p>



<br>
<br>
<div class="header">
<a name="2_4"></a>2.4.	Копирование</div>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Копирование объектов класса определяется конструкторами копирования и операторами присваивания. Рассмотрим пример:</p>



<pre>
<div class="code">
class Employee
{
  // ...
public:
  // ...
  Employee(const Employee&amp;);
  Employee&amp; operator=(const Employee&amp;);
};

void f(Manager&amp; m) {
  Employee e = m; // создание e из Employee-части m
  e = m;          // присвоить Employee-часть m переменной e
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Так как копирующая функция <i>Employee</i> ничего не знает о <i>Manager</i>, копируется только <i>Employee</i>-часть <i>Manager</i>. Этот эффект часто называют <i>срезкой</i>; он нередко приводит к ошибкам и чреват сюрпризами. Операторы присваивания не наследуются.</p>



<br>
<br>
<div class="header">
<a name="2_5"></a>2.5.	Виртуальные функции</div>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Использование производных классов в качестве чего-то большего, чем просто удобного сокращения объявления связано со следующей проблемой: есть указатель типа <i>Base*</i>; к какому производному типу на самом деле принадлежит объект, на который он указывает? Существует четыре фундаментальных решения этой проблемы:</p>

<ol type="1">

<li> гарантировать, что ссылки осуществляются только на объекты одного типа;</li>

<li> поместить поле с информацией о типе (поле типа) в базовый класс;</li>

<li> использовать динамическое преобразование типа (<i>dynamic_cast</i>);</li>

<li>	использовать виртуальные функции.</li>

</ol>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Указатели на базовые классы обычно используются при проектировании классов-контейнеров, таких как множества, вектора, и списки. В подобных случаях решение 1 приведет к однородному списку объектов одного типа. Решениями 2, 3 и 4 можно пользоваться для построения разнородных списков, то есть списков, хранящих (указатели на) объекты нескольких различных типов. Решение 3 является вариантом решения 2, возможным при непосредственной поддержке со стороны языка. Решение 4 является специальным вариантом решения 2, безопасным с точки зрения типов. Комбинации решений 1 и 4 весьма мощны и очень интересны; почти во всех ситуациях они приводят к более ясному коду, чем 2 и 3.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Рассмотрим решение 4. Виртуальные функции решают проблему, связанную с полем типа, предоставляя возможность объявить в базовом классе функции, которые можно заместить в каждом производном классе. Компилятор и загрузчик гарантируют правильное соответствие между объектами и функциями, применяемыми к ним. Например:</p>



<pre>
<div class="code">
class Employee
{
  string first_name, family_name;
  short department;
  // ...
public:
  // ...
  Employee(const string&amp; name, int dept);
  virtual void print() const;
  // ...
};
</div>
</pre>



<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Ключевое слово <i>virtual</i> означает, что <i>print()</i> может действовать в качестве интерфейса как к функции <i>print()</i>, определенной в данном классе, так и к функции <i>print()</i>, определенной в производном классе. Если такие функции <i>print()</i> определены в производных классах, компилятор обеспечивает вызов соответствующей функции <i>print()</i> для любого объекта класса, производного от <i>Employee</i>.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Чтобы объявление виртуальной функции работало в качестве интерфейса к функциям, определенным в производных классах, типы аргументов функции в производном классе должны совпадать с типами аргументов, объявленными в базовом классе. Виртуальная функция <i>должна</i> быть определена для класса, в котором она впервые объявлена. Например:</p>



<pre>
<div class="code">
void Employee::print() const
{
  cout &lt;&lt; &ldquo;\nName &rdquo; &lt;&lt; first_name &lt;&lt; &ldquo;, Dep. &rdquo; &lt;&lt; department;
  // ...
}

</div>
</pre>



<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Производный класс, который не нуждается в собственной версии виртуальной функции, не обязан ее реализовывать. При создании производного класса можно реализовать требуемую функцию, только если в этом есть необходимость. Например:</p>


<pre>
<div class="code">
class Manager
{
  Employee* group;
  Short level;
  // ...
public:
  Manager(const string&amp; name, int dept, int lvl);
  void print() const;
};

void Manager::print() const
{
  Employee::print();
  cout &lt;&lt; &ldquo;\tLevel &rdquo; &lt;&lt; level;
  // ...
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Функция из производного класса с тем же именем и с тем же набором типов аргументов, что и виртуальная функция в базовом классе, <i>замещает (override)</i> виртуальную функцию из базового класса. Но замещенную виртуальную функцию можно вызвать явно (как это сделано в примере <i>Manager::print())</i>, указав имя базового класса посредством операции &laquo;::&raquo;. Пример использования виртуальной функции:</p>


<pre>
<div class="code">
void f()
{
  Employee e(&ldquo;Brown&rdquo;, 1234);
  Manager m(&ldquo;Smith&rdquo;, 1234, 3);
  Employee* pe = &amp;e;
  pe-&gt;print();
  pe = &amp;m;
  pe-&gt;print();
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 В результате <i>f()</i> выведет следующее:</p>


<pre>
<div class="code">
Name Brown, Dep. 1234
Name Smith, Dep. 1234      Level 3
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Тип, имеющий виртуальные функции, называется <i>полиморфным типом</i>. Для достижения полиморфного поведения в С++ вызываемые функции-элементы должны быть виртуальными, и доступ к объектам должен осуществляться через ссылки или указатели. При непосредственных манипуляциях с объектом (без помощи указателя или ссылки) его точный тип известен компилятору, и поэтому полиморфизм времени выполнения не требуется.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Таким образом, виртуальные функции позволяют автоматизировать процесс классификации объектов в неоднородной иерархии классов. Существенно, что базовые классы и их виртуальные функции-элементы могут быть созданы и откомпилированы до определения производных классов. Предоставляемая тем самым возможность эволюционного развития программы в большинстве случаев оказывается важнейшей ее качественной характеристикой.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Недостатки использования виртуальных функций:</p>

<ul>

<li>увеличение размера объекта из-за необходимости хранения указателя функции;</li>

<li>обращение к виртуальным функциям через указатель фактически означает отказ от возможности встраивания функции, что снижает быстродействие программы.</li>

</ul>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Виртуальные функции позволяют достичь гибкости привязки функций к объектам за счет потерь памяти и быстродействия. Виртуальной может объявляться любая функция-элемент класса, за исключением конструктора.</p>



<br>
<br>
<div class="header">
<a name="2_6"></a>2.6.	Абстрактные классы</div>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Многие классы схожи с классом <i>Employee</i> в том, что они полезны как сами по себе, так и в качестве базы для производных классов. Для таких классов методы, описанные в предыдущем разделе, являются вполне достаточными. Однако не все классы соответствуют такому образцу. Некоторые классы, такие как <i>Shape</i> (фигура), представляют абстрактную концепцию, для которой не могут существовать объекты. Класс <i>Shape</i> имеет смысл только в качестве базы для производных классов. Это можно усмотреть хотя бы из того факта, что невозможно разумно определить виртуальные функции в самом <i>Shape</i>:</p>


<pre>
<div class="code">
class Shape
{
public:
  virtual void rotate(int)   // как вращать?
  { error(&ldquo;Shape::rotate&rdquo;); }
  virtual void draw()        // как рисовать?
  { error(&ldquo;Shape::draw&rdquo;); }
  // ...
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Попытка создания фигуры такого рода допустима, но неразумна:</p>
 

<pre>
<div class="code">
Shape s;            // глупо: &laquo;фигура без формы&raquo;
</div>
</pre>   
   

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Такое объявление неразумно, потому что каждая операция с <i>s</i> приводит к выводу сообщения об ошибке.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Лучшей альтернативой является объявление виртуальных функций класса Shape в виде <i>чисто виртуальных функций</i> при помощи инициализатора =0:</p>


<pre>
<div class="code">
class Shape // абстрактный класс
{
public:
  virtual void rotate(int) = 0; // чисто виртуальная функция
  virtual void draw() = 0;      // чисто виртуальная функция
  virtual bool is_closed() = 0; // чисто виртуальная функция
  // ...
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Класс с одной или несколькими чисто виртуальными функциями называется <i>абстрактным классом</i>. Невозможно создать объект абстрактного класса:</p>


<pre>
<div class="code">
Shape s; // ошибка: переменная абстрактного класса Shape
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Абстрактный класс можно использовать только как интерфейс и в качестве базового для других классов. Например:</p>



<pre>
<div class="code">
class Point { /* ... */ };
class Circle : public Shape
{
  Point center;
  int radius;
public:
  Circle(Point p, int r);
  void rotate(int) { /* ... */ } // замещение Shape::rotate
  void draw();                   // замещение Shape::draw
  bool is_closed() { return true; } // замещение
                                    // Shape::is_closed
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Чисто   виртуальная функция, которая не определена в производном классе, остаётся чисто виртуальной, поэтому такой производный класс, как и базовый, является абстрактным. Это позволяет нам строить реализацию поэтапно:</p>


<pre>
<div class="code">
class Polygon : public Shape // абстрактный класс
                             // многоугольников
{
public:
  bool is_closed() { return true; }
  // ... draw и rotate не замещены ...
};
Polygon b; // ошибка: объявление объекта
           // абстрактного класса Polygon
class Irregular_Polygon : public Polygon
{
  Point* lp;
public:
  void draw();      // замещение Shape::draw
  void rotate(int); // замещение Shape::rotate
  // ...
};
Irregular_Polygon poly(5); // правильно (в предложении
                           // наличия конструктора)
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Понятие абстрактного класса оказывается весьма полезным средством отражения общих свойств некоторых сущностей реального мира. Создаваемая на основе абстрактного класса иерархия производных классов может оперировать с объектами, которые определяются независимо от состава операций.</p>



<br>
<br>
<div class="title">
<a name="3"></a>3.	ИЕРАРХИИ КЛАССОВ</div>


<br>
<br>
<div class="header">
<a name="3_1"></a>3.1.	Иерархии классов и абстрактные классы</div>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Абстрактный класс является интерфейсом. Иерархия классов &ndash; средство последовательного построения классов. Естественно, каждый класс предоставляет своим пользователям интерфейс, и некоторые абстрактные классы обеспечивают полезную функциональность, но, тем не менее &laquo;интерфейс&raquo; и &laquo;строительные блоки&raquo; &ndash; вот главные роли абстрактных классов и иерархии классов.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Классическая иерархия &ndash; это иерархия, в которой отдельные классы предоставляют пользователям полезные функции и одновременно являются строительными блоками для реализации более мощных или специализированных классов. Такие иерархии идеальны для поддержки программирования методом последовательных усовершенствований. Они предоставляют максимум поддержки для реализации новых классов, в то время как новые классы в значительной степени используют существующую иерархию.</p>



<br>
<br>
<div class="header">
<a name="3_2"></a>3.2.	Управление доступом</div>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Элемент класса может быть закрытым (<i>private</i>), защищенным (<i>protected</i>) или открытым (<i>public</i>):</p>

<ul>

<li> если он закрыт, его имя может использоваться в функциях-элементах и друзьях класса, в котором он объявлен;</li>

<li> если он защищен, его имя может использоваться в функциях-элементах и друзьях класса, в котором он объявлен, и классов, производных от него;</li>

<li> если он открыт, его именем может пользоваться любая функция.</li>

</ul>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Это отражает ту точку зрения, что существует три вида функций, имеющих доступ к классу: функции, реализующие класс (элементы и друзья); функции, реализующие производные классы (друзья и элементы производных классов) и все остальные функции. Управление доступом применяется одинаковым образом ко всем именам. То, к чему относится имя, не оказывает влияния на управление его использованием. Это означает, что можно иметь закрытые функции-элементы, типы, константы и т. д., так же как закрытые элементы данные.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Аналогично элементам класса базовый класс можно объявить закрытым (<i>private</i>), защищенным (<i>protected</i>) или открытым (<i>public</i>). Например:</p>



<pre>
<div class="code">
class X : public B { /* ... */ };
class Y : protected B { /* ... */ };
class Z : private B { /* ... */ };
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Открытое наследование делает производный класс подтипом базового; это наиболее распространенная форма наследования. Защищенное и закрытое наследование используются для выражения деталей и реализации. Защищенные базовые классы полезны в иерархиях классов, в которых дальнейшее построение производных классов является нормой.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Спецификаторы доступа к базовому классу можно опустить. В этом случае, если базовым является класс, наследование будет закрытым, а если базовым является структура &ndash; то открытым. Например:</p>


<pre>
<div class="code">
class B1 { /* ... */ };
struct B2 { /* ... */ };

class XX : B1 { /* ... */ }; // B1 &ndash; закрытый базовый класс
class YY : B2 { /* ... */ }; // B2 &ndash; открытая базовая
                             // структура
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Чтобы сделать код более понятным, лучше использовать явный спецификатор.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Спецификатор доступа к базовому классу управляет доступом к элементам базового класса и преобразованием указателей и ссылок из типа производного класса в тип базового класса. Рассмотрим класс <i>Derived</i>, производный класса <i>Base</i>:</p>

<ul>

<li> если <i>Base</i> является закрытым базовым классом, его открытые и защищенные элементы могут быть использованы только функциями-элементами и друзьями <i>Derived</i>. Только друзья и элементы <i>Derived</i> могут преобразовать <i>Derived*</i> в <i>Base*</i>;</li>

<li> если <i>Base</i> является защищенным базовым классом, его открытые и защищенные элементы могут быть использованы только функциями-элементами и друзьями класса <i>Derived</i> и его производных классов. Только друзья и элементы <i>Derived</i> и его производных классов могут преобразовать <i>Derived*</i> в <i>Base*</i>;</li>

<li> если <i>Base</i> является открытым базовым классом, его открытые элементы могут быть использованы любой функцией. Кроме того, его защищенные элементы могут быть использованы элементами и друзьями класса <i>Derived</i> и его производных. Любая функция может преобразовать <i>Derived*</i> в <i>Base*</i>.</li>

</ul>


<br>
<br>
<div class="header">
<a name="3_3"></a>3.3.	Множественное наследование и разрешение неоднозначности</div>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Класс может иметь более одного непосредственного базового класса, то есть после &laquo;:&raquo; в объявлении класса может быть указано несколько классов. Рассмотрим задачу моделирования, в которой параллельные задачи представлены классом <i>Task</i> (задача), а сбор и вывод данных осуществляется при помощи класса <i>Displayed</i> (отображаемый). Определим класс моделируемых сущностей, класс <i>Satellite</i> (спутник):</p>


<pre>
<div class="code">
class Satellite : public Task, public Displayed
{
  // ...
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Использование более одного непосредственного базового класса обычно называется <i>множественным наследованием</i>.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Кроме операций, определенных для <i>Satellite</i>, можно воспользоваться объединением операций <i>Task</i> и <i>Displayed</i>. Например:</p>


<pre>
<div class="code">
void f(Satellite&amp; s)
{
  s.draw();      // Displayed::draw()
  s.delay(10);   // Task::delay()
  s.transmit();  // Satellite::transmit
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Аналогичным образом <i>Satellite</i> можно передать в функции, которые ожидают <i>Task</i> или <i>Displayed</i>. Например:</p>


<pre>
<div class="code">
void highlight(Displayed*);
void suspend(Task*);

void g(Satellite* p)
{
  highlight(p); // передать указатель на Displayed-часть
                // Satellite
  suspend(p);   // передать указатель на Task-часть
                // Satellite
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Виртуальные функции работают как обычно. Например:</p>



<pre>
<div class="code">
class Task
{
  // ...
  virtual void pending() = 0;
};

class Displayed
{
  // ...
  virtual void draw() = 0;
};

class Satellite: public Task, public Displayed
{
  // ...
  void pending(); // замещение Task::pending()
  void draw();    // замещение Displayed::draw()
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Такой подход гарантирует, что функции <i>Satellite::draw()</i> и <i>Satellite::pending()</i> будут вызваны для <i>Satellite</i>, проинтерпретированного как <i>Displayed</i> и <i>Task</i> соответственно.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Два базовых класса могут иметь функции-элементы с одинаковым именем. Например:</p>


<pre>
<div class="code">
class Task {
  // ...
  virtual debug_info* get_debug();
};
class Displayed
{
  // ...
  virtual debug_info* get_debug();
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 При использовании <i>Satellite</i> неоднозначности для этих функций должны быть устранены:</p>


<pre>
<div class="code">
void f(Satellite* sp)
{
  debug_info* dip = sp-&gt;get_debug(); // ошибка: неоднозначно
  dip = sp-&gt;Task::get_debug();       // правильно
  dip = sp-&gt;Displayed::get_debug();  // правильно
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Однако явное устранение неоднозначности довольно неудобно, поэтому лучше разрешить эти проблемы, определив новую функцию в производном классе:</p>


<pre>
<div class="code">
class Satellite: public Task, public Displayed
{
  // ...
  // замещение Task::get_debug() и Displayed::get_debug()
  debug_info* get_debug()
  {
    debug_info* dip1 = Task::get_debug();
    debug_info* dip2 = Displayed::get_debug();
    return dip1-&gt;merge(dip2);
  }
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Это локализует информацию о базовых классах <i>Satellite</i>. Так как <i>Satellite::get_debug()</i> замещает функции <i>get_debug()</i> из обоих классов, <i>Satellite::get_debug()</i> вызывается при каждом вызове <i>get_debug()</i> для объектов <i>Satellite</i>.</p>



<br>
<br>
<div class="header">
<a name="3_4"></a>3.4.	Виртуальные базовые классы</div>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 При задании более чем одного базового класса возникает вероятность того, что какой-либо класс дважды окажется базовым для другого класса. Например, если бы каждый из классов <i>Task</i> и <i>Displayed</i> был производным от класса <i>Process</i>, у <i>Satellite</i> было бы два <i>Process</i>:</p>


<pre>
<div class="code">
class Process { /* ... */ };
class Task : public Process { /* ... */ };
class Displayed : public Process { /* ... */ };
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Это не вызывает никаких проблем. Используются два отдельных объекта <i>Process</i>, которые не зависимы друг от друга. Для обращения к таким объектам нужно использовать операцию разрешения области видимости &laquo;::&raquo;. В тех случаях, когда общий базовый класс не должен быть представлен в виде двух отдельных объектов, нужно воспользоваться виртуальным базовым классом:</p>


<pre>
<div class="code">
class Task : public virtual Process { /* ... */ };
class Displayed : public virtual Process { /* ... */ };
class Satellite : public Task, public Displayed { /* ... */ }
</div>
</pre>



<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Каждый виртуальный базовый класс в производном классе будет представлен одним и тем же объектом.</p>



<br>
<br>
<div class="title">
<a name="4"></a>4.	ИНДИВИДУАЛЬНЫЕ ЗАДАНИЯ</div>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Для всех вариантов заданий:</p>

<ul>

<li>управление по созданию и уничтожению объектов классов должно осуществляться посредством операций <b>new</b> и <b>delete</b>;</li>

<li>доступ ко всем объектам классов должен осуществляться посредством указателей;</li>

<li>захват и освобождение ресурсов в классах (там где это необходимо) должен осуществляться парой конструктор(ы)/деструктор.</li>

</ul>

<br>
<br>
<div class="header">
<a name="|||||"></a>Варианты заданий</div>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>1)</b>	Реализуйте простую графическую систему с использованием графических средств Win32 API. Абстрактный класс</p>


<pre>
<div class="code">
class Shape
{
protected:
	HDC hdc;		//контекст устройства на котором рисуем
	int width;		//толщина линий
	COLORREF color;		//цвет линий
	HPEN hpen;		//перо для рисования
public:
	Shape(HDC hd)
	{ hdc = hd; width = 1; color = RGB(0, 0, 0); }
	void SetWidth(int w);
	void SetColor(COLORREF c);
// функция рисования должна переопределяться в производных
// классах
	virtual void Draw(void) = 0;
};
</div>
</pre>

является общим интерфейсом для классов <b>Dot</b> (точка), <b>Line</b> (линия), <b>Triangle</b> (треугольник), <b>Rectangle</b> (прямоугольник), <b>Ellipse</b> (эллипс). <b>Line</b> задается парой объектов <b>Point</b>, который не является производным от <b>Shape</b>, <b>Triangle</b> задается тройкой (массивом) объектов <b>Point</b>. Предусмотреть возможность установки для всех фигур толщины и цвета линии, цвета заливки. <b>Shape</b> невидим до вызова функции <b>Draw()</b>. Пример использования:

<pre>
<div class="code">
Shape * p = 0;
...
Point pt[3] = {{20,10},{40,60,},{30,25}};
p = new Triangle(pt);
p-&gt;SetWidth(3);
p-&gt;SetColor(RGB(20, 200, 150));
p-&gt;Draw();
...
 </div>
</pre>
 

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>2)</b>	Определите класс</p>


<pre>
<div class="code">
class Person	//любой человек
{
protected:
	char	fio[100];		//ФИО
	char	date_of_birth[12];	//дата рождения
	char	pol[5]			//пол
	Person * next;			//указатель на следующего в списке
public:
	// ...
	void SetPersonInfo(char*, char*, char*);
//добавить следующего в список
//функция вывода информации переопределяется в
//производных классах
	virtual void PersonInfo(void);
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Производным от него будет класс <b>Employee</b> (сотрудник), в котором содержится дополнительная информация о должности сотрудника.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Создайте производный от <b>Employee</b> класс <b>Manager</b> (менеджер), в котором дополнительными свойствами будут наименование отдела. Объявите в классе переменную <b>Person * employers</b>, которая будет указывать на список сотрудников.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Создайте производный от <b>Employee</b> класс <b>Chief</b> (директор), в котором дополнительным свойством будет наименование фирмы. Объявите в классе переменную <b>Person * managers</b>, которая будет указывать на список менеджеров.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			В классы <b>Manager</b> и <b>Chief</b> необходимо добавить функции добавления соответственно сотрудника и менеджера (<b>AddEmployee()</b> и <b>AddManager()</b>).</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			В программе создайте фирму &laquo;Рога и Копыта&raquo;, директор Остап Бендер, Шура и Паниковский &ndash; менеджеры. У каждого менеджера должно быть по три сотрудника. Пример использования:</p>


<pre>
<div class="code">
Chief * ch = new Chief(&ldquo;Рога и копыта&rdquo;);
ch-&gt;SetPersonInfo(&ldquo;Остап Бендер&rdquo;, &ldquo;12.12.1212&rdquo;, &ldquo;м&rdquo;);
Manager * m1 = new Manager(&ldquo;Рога&rdquo;);
m1-&gt;SetPersonInfo(&ldquo;Шура&rdquo;, &ldquo;01.01.0101&rdquo;, &ldquo;м&rdquo;);
Manager * m2 = new Manager(&ldquo;Копыта&rdquo;);
m1-&gt;SetPersonInfo(&ldquo;Паниковский&rdquo;, &ldquo;10.10.1010&rdquo;, &ldquo;м&rdquo;);
ch-&gt;AddManager(m1);
ch-&gt;AddManager(m2);
...
</div>
</pre>
 

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>3)</b>	Автомобильный транспорт описывается классом &laquo;Автомобиль&raquo; (<b>Automobile</b>), который содержит следующую информацию: марка автомобиля, тип двигателя (карбюраторный или дизельный), мощность двигателя в л.с., масса автомобиля, пробег в км.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			&laquo;Легковой автомобиль&raquo; (<b>Car</b>) производный от &laquo;Автомобиля&raquo; содержит дополнительную информацию: расход топлива на 100 км, время разгона до 100 км/ч в секундах, количество пассажирских мест.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			&laquo;Грузовой автомобиль&raquo; (<b>Lorry</b>) производный от &laquo;Автомобиля&raquo; содержит дополнительную информацию: грузоподъемность в тоннах, тип кузова (открытый или закрытый).</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			&laquo;Автобус&raquo; (<b>Bus</b>) производный от &laquo;Легкового автомобиля&raquo; содержит дополнительную информацию: количество стоячих мест.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Необходимо создать парк автомобилей автобазы в виде списка или массива, где каждый элемент представляет собой указатель на базовый класс <b>Automobile</b>, а указывает на объект производного класса.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			В базовом классе определить чисто виртуальную функцию <b>Load(int)</b>, которая в производном классе <b>Lorry</b> определяется как загрузка груза, а в классах <b>Car</b> и <b>Bus</b> &ndash; посадка пассажиров. В базовом и производных классах необходимо определить виртуальную функцию <b>Print()</b>, которая выводит на экран сведения об автотранспорте. Каждый класс должен содержать конструктор с параметрами.</p>

 

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>4)</b>	Разработать следующую иерархию классов для ролевой игры:</p>


<pre>
<div class="code">
class Weapon
{
protected:
//имя
	char name[20];
//сила удара
	int blow_power;
//сила защиты
	int protect_power;
public:
//конструктор
	Weapon(int bp, int pp)
	{
		blow_power = bp;
		protect_power = pp;
	}
//ударить
	virtual int Strike();
//защититься
	virtual int Protect(int power);
//возвратить имя оружия
	char * GetName();
};
</div>
</pre>

<pre>
<div class="code">
class Shield:public Weapon //щит
{/*
в классе необходимо определить конструктор и 
переопределить функции Strike() и Protect()
*/};
</div>
</pre>

<pre>
<div class="code">
class Club:public Weapon //дубинка
{/*
в классе необходимо определить конструктор и
переопределить функции Strike() и Protect()
*/};
</div>
</pre>

<pre>
<div class="code">
class Sword:public Weapon //меч
{/*
в классе необходимо определить конструктор и
переопределить функции Strike() и Protect()
*/};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Конструктор класса <b>Weapon</b> устанавливает значения силы удара и защиты.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Функция <b>Strike()</b> генерирует случайное число в диапазоне от 0 до <b>blow_power</b>, уменьшает <b>blow_power</b> на значение равное частному от деления сгенерированного числа на 10 и возвращает сгенерированное число.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Функция <b>Protect()</b> получает силу удара, генерирует случайное число в диапазоне от 0 до <b>protect_power</b>, уменьшает <b>protect_power</b> на значение равное частному от деления сгенерированного числа на 10, вычисляет разницу между силой удара <b>power</b> и сгенерированным числом и, если результат положительный то возвращается это число, если нет то возвращается 0. Возвращаемое значение есть сила повреждения.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Все классы реализовать в отдельном h-файле, имя которого совпадает с именем класса.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>5)</b>	Разработать иерархию классов для ролевой игры:</p>


<pre>
<div class="code">
class Personage
{
protected:
//имя
	char name[20];
//удача в атаке
	int luck_attack;
//удача в защите
	int luck_guard;
//здоровье
	int health;
//оружие нападения
	Weapon * weapon_attack;
//оружие защиты
	Weapon * weapon_guard;
public:
	Personage(char *);
	virtual void Attack(Personage*);
	virtual void Guard(int);
//false &ndash; игрок еще жив, иначе true
	bool IsDead() { return (health &lt;= 0); }
//установить оружие атаки
	void SetWeaponAttack(Weapon * w)
	{
		weapon_attack = w;
	}
//установить оружие защиты
	void SetWeaponGuard(Weapon * w)
	{
		weapon_guard = w;
	}
};
</div>
</pre>

<pre>
<div class="code">
class Warrior:public Personage //воин
{/*
в классе необходимо определить конструктор и
переопределить функции Attack() и Guard()
*/};
</div>
</pre>

<pre>
<div class="code">
class Monster:public Personage //монстр
{/*
в классе необходимо определить конструктор и
переопределить функции Attack() и Guard()
*/};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Функция <b>Attack()</b> инициирует атаку игроком противника. В начале функция выбирает случайным образом оружие и вычисляет силу удара. Затем вычисляется удача в атаке по следующей формуле:</p>


<pre>
<div class="code">
удача_в_атаке = случайное_число(-сила_удара/2, сила_удара/2)
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Сила удара суммируется с удачей и передается функции Guard() противника.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Функция <b>Guard()</b> инициирует защиту от нападения противника. Вначале функция выбирает случайно оружие для защиты и вычисляет силу повреждения. Затем вычисляет удачу в защите по аналогичной для атаки схеме, вычитает удачу из силы повреждения и полученный результат вычитается из здоровья.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Все классы реализовать в отдельном h-файле, имя которого совпадает с именем класса.</p>

 

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>6)</b>	Разработать класс <b>Combat</b> для моделирования поединка между двумя персонажами (задание №5) с использованием оружия (задание №4). Конструктор класса должен запрашивать тип персонажей и предлагать на выбор оружие. Функция <b>Start()</b> должна случайно выбирать игрока, который будет ходить (атаковать). Результаты ходов должны отображаться на экране, например:</p>


<pre>
<div class="code">
ход 1:
атака имя:	сила_удара	удача	рез_сила	здоровье
защита имя:	сила_поврежд	удача	рез_поврежд	здоровье
...
ход 5:
атака имя:	сила_удара	удача	рез_сила	здоровье
защита имя:	сила_поврежд	удача	рез_поврежд	здоровье
...
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Как только игрок погибает бой прекращается.</p>


<pre>
<div class="code">
class Combat
{
	Personage * p1; //игрок 1
	Personage * p2; //игрок 2
	Personage * a_player; //атакующий игрок
	Personage * g_player; //защищающийся игрок
public:
	Combat();
	~Combat();
	void Start();
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Все классы реализовать в отдельном h-файле, имя которого совпадает с именем класса.</p>

<center>[<a href="lab4.html">Предыдущая работа</a>][<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="lab6.html">Следующая работа</a>]</center>


</body>
</html>
