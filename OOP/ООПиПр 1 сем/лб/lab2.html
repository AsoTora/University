<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Лабораторная работа №2</title>
<link type="text/css" rel="stylesheet" href="style.css">
</head>
<body>
	
		
<div class="title">ЛАБОРАТОРНАЯ РАБОТА № 2</div>
		
<div class="title">КЛАССЫ</div>
		
<center>[<a href="lab1.html">Предыдущая работа</a>][<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="lab3.html">Следующая работа</a>]</center>
		
<br>
<br>
<div class="title">
<a name="0"></a>Оглавление</div>
		
<ol type="1">
			
<li>
				
<a href="#1">Цель работы</a>
			
</li>
			
<li>
				
<a href="#2">Классы объектов</a>
			
</li>
			
<ul>
			
<li>
				
<a href="#2_1">Понятие класса объектов</a>
			
</li>
			
<li>
<a href="#2_2">Управление доступом
			</a>
</li>
			
<li>
<a href="#2_3">Функции-элементы класса
			</a>
</li>
			
<li>
<a href="#2_4">Константные функции-элементы
			</a>
</li>
			
<li>
<a href="#2_5">Ссылка на себя
			</a>
</li>
			
<li>
<a href="#2_6">Статические элементы класса
			</a>
</li>
			
<li>
<a href="#2_7">Дружественные функции класса
			</a>
</li>
			
</ul>
			
<li>
				
<a href="#3">Индивидуальные задания</a>
			
</li>
		
</ol>
		
<br>
<br>
<div class="title">
<a name="1"></a>1.	ЦЕЛЬ РАБОТЫ</div>
		
<ol type="1">
			
<li>Изучение возможностей языка C++ в определении пользовательских типов данных.</li>
			
<li>Изучение правил определения и переопределения функций доступа к объектам класса.</li>
			
<li>Использование статических элементов классов и дружественных функций.</li>
		
</ol>
		
		
<br>
<br>
<div class="title">
<a name="2"></a>2.	КЛАССЫ ОБЪЕКТОВ</div>
		
<div class="title">
<a name="2_1">2.1.	Понятие класса объектов</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Целью введения концепции классов в С++ является предоставление программисту средств создания новых типов, которые настолько же удобны в использовании, как и встроенные. Кроме того, производные классы (лаб. раб. № 4) и шаблоны (лаб. раб. № 5) представляют способы организации классов, имеющих между собой нечто общее.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Тип является конкретным представлением некоторой концепции. Например, встроенный тип <i>float</i> вместе с операциями +, &ndash;, * и т. д. представляет конкретное воплощение математической концепции вещественного числа. Класс &ndash; это определяемый пользователем тип. Мы создаем новые типы для определения концепции, не выражаемой непосредственно встроенными типами. Например, мы могли бы ввести тип <i>Trunk_line</i> (междугородняя линия) в программе, имеющей отношение к телефонии, тип <i>Explosion</i> (взрыв) в видеоигре или тип <i>list&lt;Paragraph&gt;</i> (список абзацев) в программе обработки текста. Программы, типы в которых близко соответствуют концепциям приложения, обычно легче понимать и модифицировать. Тщательно подобранный набор типов, определяемых пользователем, делает программу более краткой и выразительной. Кроме того, такие типы дают возможность проведения разнообразного анализа кода. В частности, они позволяют компилятору обнаружить случаи недопустимого использования объектов, которые в противном случае не были бы выявлены вплоть до этапа тестирования.
Основной смысл введения новых типов состоит в разделении малозначащих деталей реализации (например, расположение в памяти составных частей объектов данного типа) от свойств, имеющих определяющее значение для правильного использования сущности (например, полный набор функций доступа к данным). Подобное разделение лучше всего выражается в терминах ограничения доступа к данным извне и использования для этой цели специальных процедур в рамках четко определенного интерфейса.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			В языке С++ определение классов ведется посредством расширения понятий структуры (<i>struct</i>) и обьединения (<i>union</i>). Традиционная для языка С интерпретация таких понятий остается в силе, что позволяет использовать программы на языке С без изменения исходного текста.
Синтаксис определения класса на языке С++ имеет вид</p>
	
	
<pre>
<div class="code">
вид_класса имя_класса
{
  описание_элементов_класса
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Определение класса представляет лишь описание некоторого типа объектов, имя которого "вид_класса имя_класса". Элемент "вид_класса" может принимать значения <i>struct</i>, <i>union</i> или <i>class</i>. Между символами '}' и ';' можно разместить список имен определяемых объектов класса с использованием, при необходимости, операции инициализации. Вне оператора определения класса объекты определяются операторами декларации вида</p>
	
	
<pre>
<div class="code">
вид_класса имя_класса список_имен_обьектов;
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			В большинстве случаев наиболее целесообразно определение класса и его элементов поместить в отдельный заголовочный файл.</p>
		
		
		
<div class="title">
<a name="2_2">2.2.	Управление доступом</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Описание элементов класса может в общем случае включать декларацию элементов данных представления объекта и/или функций доступа к данным с указанием <i>атрибутов права доступа</i>. Иногда элементами являются описания собственных типов класса (например, структурированных типов объектов и перечислений). Принципиально возможно использование вложенных классов.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Элементы класса могут иметь один из атрибутов права доступа:</p>
	
<ul>	
<li>
<i>private</i> (локальный) &ndash; доступ только из функций доступа внутри класса;</li>
		
<li>
<i>protected</i> (защищенный) &ndash; доступ из функций доступа внутри класса и производных классов;</li>
		
<li>
<i>public</i> (глобальный) &ndash; доступ из любых функций (элементы интерфейса пользователя класса).</li>
		
</ul>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Элементы класса вида <i>union</i> могут иметь только атрибут доступа <i>public</i>. Различие между классами видов <i>struct</i> и <i>class</i> лишь в значении по умолчанию атрибутов доступа: элементы класса вида struct имеют атрибут <i>public</i>, а класса вида <i>class &ndash; private</i>.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Явное назначение атрибута доступа к элементам класса оформляется записью перед описанием элементов ключевого слова <i>private</i>, <i>protected </i> или <i>public</i> и символа <i>&lt;&lt;:&gt;&gt;</i> (для последующих элементов с совпадающим атрибутом доступа повторение описания этого атрибута не обязательно).</p>

		
<div class="title">
<a name="2_3">	2.3.		Функции-элементы класса</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Рассмотрим реализацию концепции даты с использованием класса <i>Date</i>. Содержится набор функций, осуществляющих манипуляции с переменными&ndash;датами:</p>
	
	
<pre>
<div class="code">
class Date
{
  int d;
  int m;
  int y;
};

void init_date(Date&amp; d, int dd, int mm, int yy);
void add_year(Date&amp; d, int yy);
void add_month(Date&amp; d, int mm);
void add_day(Date&amp; d, int dd);
</div>
</pre>
	
		Здесь нет явной связи между типом данных и функциями. Такую связь можно установить, объявив функции в качестве элементов класса:
	
	<pre>
<div class="code">

class Date
{
  int d;
  int m;
  int y;
public:
  void init(int dd, int mm, int yy);
  void add_year(int yy);
  void add_month(int mm);
  void add_day(int dd);
};
</div>
</pre>
	
		
Функции, объявленные внутри определения класса называются <i>функциями-элементами</i> и их можно вызывать только для переменной соответствующего типа, используя стандартный синтаксис доступа к элементам структуры. Например:
	
	<pre>
<div class="code">
Date my_birthday;
void f()
{
  Date today;

  today.init(14, 1, 2001);
  my_birthday.init(29, 2, 1980);
  Date tomorrow = today;
  tomorrow.add_day(1);
  // ...
}
</div>
</pre>
	
		
Так как различные классы могут иметь функции-элементы с одинаковыми именами, при определении функции-элемента нужно указать имя класса:
	
	<pre>
<div class="code">
void Date::init(int dd, int mm, int yy)
{
  d = dd;
  m = mm;
  y = yy;
}
</div>
</pre>
	
		
В теле функции-элемента имена элементов этого же класса можно использовать без явного указания объекта. В данном случае имя относится к элементу того объекта, для которого вызвана функция. Функция-элемент класса всегда знает, для какого объекта она вызвана.

<div class="title">

<a name="2_4">2.4.			Константные функции-элементы</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определенный класс <i>Date</i> предоставляет функции-элементы, которые присваивают и изменяют значение объекта типа <i>Date</i>. Обеспечим способ проверки значения объекта <i>Date</i>, добавив функции, возвращающие значения дня, месяца и года:</p>
	
	
<pre>
<div class="code">
class Date
{
  int d, m, y;
public:
  int day() const { return d; }
  int month() const { return m; }
  int year() const;
  // ...
};
</div>
</pre>
	
		
Ключевое слово <i>const</i> после списка аргументов означает, что функция не изменяет состояние <i>Date</i>.
		<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Естественно, компилятор обнаружит случайные попытки нарушить это обещание. Например:</p>
	
	
<pre>
<div class="code">
int Date::year() const
{
  return y++; // ошибка: попытка изменить значение
              // элемента в константной функции
}
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Константную функцию-элемент можно вызвать как для константного, так и неконстантного объекта, в то время как неконстантную функцию-элемент можно вызвать только для объекта, не являющегося константой. Например:</p>
	
	
<pre>
<div class="code">

void f(Date&amp; d, const Date&amp; cd)
{
  int i = d.year();   // правильно
  d.add_year(1);      // правильно
  int j = cd.year();  // правильно
  cd.add_year(1);     // ошибка: нельзя изменить значение
                      // константы cd
}
	
	</div>
</pre>
	
	
		
<div class="title">
<a name="2_5">	2.5.		Ссылка на себя</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Функции-модификаторы состояния <i>add_year()</i>, <i>add_month()</i> и <i>add_day()</i> были определены, как не возвращающие значения. При использовании подобных связанных функций иногда возникает желание выстроить операции в цепочку. Для этого требуется, чтобы функции возвращали ссылку на измененный объект. Например, можно было бы написать</p>
	
	
<pre>
<div class="code">
void f(Date&amp; d)
{
  d.add_day(1).add_month(1).add_year(1);
}

чтобы добавить один день, один месяц и один год к <i>d</i>. Для этого нужно, чтобы функции возвращали ссылку на <i>Date</i>:

class Date
{
  // ...
  Date&amp; add_year(int yy);
  Date&amp; add_month(int mm);
  Date&amp; add_day(int dd);
}
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Каждая нестатическая функция-элемент знает, для какого объекта она вызвана, и может явно на него ссылаться. Например:</p>
	
	
<pre>
<div class="code">
Date&amp; Date::add_year(int yy)
{
  // leapyear &ndash; високосный год
  if(d == 29 &amp;&amp; m == 2 &amp;&amp; !leapyear(y + yy))
  {
    d = 1;
    m = 3;
  }
  y += yy;
  return *this;
}
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Выражение <i>*this</i> означает объект, для которого вызвана функция-элемент. В нестатической функции-элементе ключевое слово <i>this</i> является указателем на объект, для которого вызвана функция. В нестатической функции-элементе класса <i>Х this</i> имеет тип <i>Х*</i>. Однако, это не обычная переменная; невозможно получить ее адрес или присвоить ей что-либо. В константной функции-элементе класса <i>Х this</i> имеет тип <i>const X*</i> для предотвращения модификации самого объекта.</p>
		
<div class="title">
<a name="2_6">2.6.	Статические элементы класса</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Элементы класса (функции и данные), объявляемые с дополнительным атрибутом <i>static</i>, называются <i>статическими</i>.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Статический элемент данных, независимо от количества объектов, будет размещен в единственном экземпляре в статической памяти и инициализирован один раз (по умолчанию, поле статического элемента заполняется нулями). Таким образом, предоставляется возможность использования общих переменных для всех объектов класса, а потребность в глобальных переменных сокращается.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Статическая функция-элемент не привязана к объектам класса. Указатель <i>this</i> ей не передается, поэтому она имеет доступ только к статическим элементам класса.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			В любых функциях-элементах класса именование статических элементов ведется обычным образом, но для обращения к открытым элементам такого вида извне их имена дополняются слева именем класса и символами операции привязки <i>&lt;&lt;::&gt;&gt;</i>.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Рассмотрим пример использования статических элементов:</p>
	
	
<pre>
<div class="code">
class List
{  // список строк:
  static List *head;  // указатель списка
  static int size;    // размер буфера строк
  List * next;        // указатель следующего элемента
  char * data;        // указатель поля данных
public:
  void append(char *item)
  {  // добавление строки
    int n = strlen(item)+1;
    next = head; head = this;
    data = new char[n];
    strcpy(data, item);
    if(size &gt; n) size = n;
  }
  static void print()
  {  // вывод списка строк
     int i=0;
     for(List * item = head; item != NULL; item = item-&gt;next)
       printf("\n %4d) %*s", ++i, size, item-&gt;data);
  }
  static int isempty()
  {  // проверка наличия списка строк
     return (head == NULL);
  }
};

void main()
{
  (new List)-&gt;append("КАФЕДРА");
  (new List)-&gt;append("ФАКУЛЬТЕТ");
  (new List)-&gt;append("ВУЗ");
  if(!List::isempty())
  {
    printf("\nСПИСОК ПОДРАЗДЕЛЕНИЙ:\n");
    List::print();
  }
}

Результаты работы программы:

СПИСОК ПОДРАЗДЕЛЕНИЙ:
1) ВУЗ
2) ФАКУЛЬТЕТ
3) КАФЕДРА
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Можно еще раз обратить внимание на использование функции-элемента <i>List::append</i> - указатель <i>this</i> получается в результате операции захвата памяти.
</p>
		
<div class="title">
<a name="2_7">2.7.	Дружественные функции класса</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
<i>Дружественной</i> называется объявленная в классе функция с атрибутом <i>friend</i>, которая, не являясь элементом класса, может использовать его любые элементы. Декларация дружественной функции может проводиться в любом месте описания класса. Декларация может проводиться в форме описания и/или определения с использованием всех возможностей языка С++. При определении дружественной функции в классе ей автоматически приписывается атрибут <i>inline</i>.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Дружественная функция не привязана к объектам класса. Указатель <i>this</i> ей, как и статическим функциям-элементам, не передается. Операция вызова дружественной функции не использует синтаксис выбора элемента структуры, а записывается в обычной форме.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Иллюстрация различия между функцией-элементом и дружественной функцией класса:</p>
	
	
<pre>
<div class="code">
class Example
{
  int a;
// Описание дружественной функции (может быть в любом месте)
  friend void friend_set (Example*, int);
public:
  void member_set(int);
};

// Определение дружественной функции
void friend_set(Example * p, int i) { p-&gt;a = i; }

// Определение функции-элемента
void Example::member_set(int i)
{
  a = i;  // Example::a = i; &lt;===&gt; this-&gt;a = i;
}

Example object; // декларация объекта
void f()
{
// Эквивалентные по действию операторы
  friend_set(&amp;object, 1992); // вызов дружественной функции
  object.member_set(1992);   // вызов функции-элемента
}
</div>
</pre>
	
Функция-элемент одного класса может быть дружественной другому классу:
	<pre>
<div class="code">
class X
{
  // ...
  void f(); // любой атрибут доступа
};

class Y
{
  // ...
  friend void X::f(); // разрешение доступа к любым элементам
                      // класса Y функции X::f()
};

Если все функции класса X дружественны классу Y, то можно использовать сокращение вида

class Y
{
  friend X;
  // ...
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Таким образом,  дружественные функции могут  использоваться для связи элементов разных классов.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Принципиальное различие между функциями-элементами и дружественными функциями лишь в синтаксисе доступа к элементам класса. Предпочтение в использовании того или иного вида функций чаще всего определяется контекстом их использования.</p>
		
	
		
		
		
		
<br>
<br>
<div class="title">
<a name="3"></a>3.	ИНДИВИДУАЛЬНЫЕ ЗАДАНИЯ</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Для всех вариантов заданий:</p>
		
<ul>
			
<li>определить классы их свойства и методы в соответствии с вариантом задания;</li>
			
<li>в функции <b>main()</b> реализовать демонстрацию работы с объектами созданных классов;</li>
	
		
</ul>
		
<br>
<br>
<div class="header">
<a name="|||||"></a>ЗАМЕЧАНИЯ:</div>
		
<br>
<br>
<div class="header">
<a name="|||||"></a>Варианты заданий</div>
		
	
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
				Весь ввод/вывод должен осуществляться только внутри функции <b>main()</b>.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Передача в функции объектов типа класс должна осуществляться через указатель либо ссылку на объект.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Все другие нестатические данные должны передаваться функциям через параметры.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Все нестатические элементы класса должны иметь закрытый атрибут доступа. Доступ извне к таким элементам должен осуществляться через функции-элементы класса.</p>

		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
		


<b>1)</b>	Определите класс <b>Date</b> для хранения даты:</p>


<pre>
<div class="code">
class Date
{
	unsigned y;	//год
	unsigned m;	//месяц
	unsigned d;	//день
	...
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите элементы-функции, которые читают дату из потока ввода, выводят дату. Определите функцию (с параметрами по умолчанию), которая добавляет день, месяц или год к дате. Определите дружественную функцию, которая вычисляет разницу в днях между двумя датами.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
<b>2)</b>	Определите класс <b>Time</b> для хранения времени:</p>


<pre>
<div class="code">
class Time
{
	unsigned h;	//часы
	unsigned m;	//минуты
	unsigned s;	//секунды
	...
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите элементы-функции, которые читают время из потока ввода, выводят время. Определите функцию (с параметрами по умолчанию), которая добавляет часы, минуты или секунды ко времени. Определите дружественную функцию, которая возвращает количество секунд прошедших от time1 до time2.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
<b>3)</b>	Определить класс <b>TextFile</b> для представления текстовых файлов</p>


<pre>
<div class="code">
class TextFile
{
	char name[256];	//имя файла
	int length;		//размер файла
	char * buff;		//буфер для текста
	...
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите в классе следующие функции:</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Open()</b> &ndash; открытие файла. Функция должна создать буфер и прочитать в него содержимое файла;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>AddText()</b> &ndash; добавление текста в конец файла;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>PasteText()</b> &ndash; вставка текста в произвольное место;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Save()</b> &ndash; сохранение файла. Функция должна иметь параметр &ndash; имя файла со значением по умолчанию NULL. Если используется значение по умолчанию, то файл сохраняется с именем, которое было указано при его открытии;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Print()</b> &ndash; вывод содержимого файла на экран.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
<b>4)</b>	Определите узел бинарного дерева следующим образом:</p>


<pre>
<div class="code">
class Node
{
	char name[10];	//имя узла
	Node * left;		//левая ветвь
	Node * right;	//правая ветвь
	...
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите в классе следующие функции:</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Init()</b> &ndash; инициализация узла. Функция должна установить указатели на левый и правый узел в ноль;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>AddNode()</b> &ndash; добавление узла в левую или правую ветви. Если слева нет узла, то добавить слева, если справа нет узла, то добавить справа, иначе ничего не добавлять;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>DelTree()</b> &ndash; удаление поддеревьев;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Print()</b> &ndash; рекурсивная функция вывода дерева на экран.</p>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>5)</b>	Определите элемент односвязного списка и список:</p>


<pre>
<div class="code">
struct ListItem
{
	char * data;	//указатель на данные
	List * next;	//указатель на следующий элемент
};
class List
{
	ListItem * list;
	...
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите в классе <b>List</b> следующие функции:</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Init()</b> &ndash; инициализация списка. Установка list в ноль;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Add()</b> &ndash; добавление нового элемента в начало или конец списка (предусмотреть обе возможности);</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Add()</b> &ndash; перегруженная функция добавления нового элемента в позицию с индексом i;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Print()</b> &ndash; вывод содержимого списка на экран;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Delete()</b> &ndash; удаление i-го элемента из списка.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
<b>6)</b>	Имеется элемент стека (дисциплина обслуживания LIFO) и стек:</p>


<pre>
<div class="code">
struct StackItem
{
	char * data;	//указатель на данные
	Stack * prev;	//указатель на предыдущий элемент
};
class Stack
{
	StackItem * stack;
	...
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите в классе <b>Stack</b> следующие функции:</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Init()</b> &ndash; инициализация стека. Установка stack в ноль;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Push()</b> &ndash; поместить данные в стек;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Pop()</b> &ndash; извлечь данные из стека (при этом элемент удаляется из стека);</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Print()</b> &ndash; дружественная функция вывода на экран содержимого стека.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
<b>7)</b>	Определите класс <b>String</b> для хранения строки символов:</p>


<pre>
<div class="code">
class String
{
	char * str;	//строка
	int length;	//длина строки
	...
};
</div>
</pre>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите в классе следующие функции:</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Init()</b> &ndash; инициализация некоторой строкой;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Concat()</b> &ndash; добавление в конец строки другой строки;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Length()</b> &ndash; определение длины строки;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Char()</b> &ndash; функция возвращающая символ с индексом i;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Print()</b> &ndash; дружественная функция вывода строки на экран.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
<b>
8)</b>	Имеется элемент очереди и очередь (дисциплина обслуживания FIFO):</p>


<pre>
<div class="code">
struct QueueItem
{
	char * data;		//указатель на данные
	QueueItem * next;	//указатель на следующий элемент очереди
}
class Queue
{
	QueueItem * queue;
	...
};</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите в классе <b>Queue</b> следующие функции:</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Init()</b> &ndash; инициализация очереди. Установка <b>queue</b> в ноль;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Put()</b> &ndash; поместить элемент в конец очереди;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Get()</b> &ndash; извлечь элемент из очереди (при этом элемент удаляется из очереди);</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Print()</b> &ndash; статическая функция вывода на экран содержимого очереди.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
<b>9)</b>	Определите класс <b>Complex</b>:</p>


<pre>
<div class="code">
class Complex
{
	double re;	//вещественная часть
	double im;	//мнимая часть
	...
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите в классе следующие функции:</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Init()</b> &ndash; инициализация числа (установка значений действительной и мнимой части);</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Add()</b>, <b>Sub()</b>, <b>Mul()</b>, <b>Div()</b> &ndash; операции &laquo;+&raquo;, &laquo;&ndash;&raquo;, &laquo;*&raquo; и &laquo;/&raquo; над комплексными числами. Все функции должны возвращать ссылку на новое комплексное число, содержащее результат операции;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Print()</b> &ndash; статическая функция вывода значения комплексного числа на экран в алгебраической или показательной формах.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
<b>10)</b>	Определите класс <b>TreeNode</b> &ndash; узел:</p>


<pre>
<div class="code">
class TreeNode
{
	char name[10];		//имя узла
	TreeNode * nodes;	//список дочерних узлов
	TreeNode * next;	//следующий узел на том же уровне
	...
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите в классе следующие функции:</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Init()</b> &ndash; инициализация узла. Установка nodes и next в ноль;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>AddNode()</b> &ndash; добавление нового узла на том же уровне;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>AddChildNode()</b> &ndash; добавление нового дочернего узла;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>DelTree()</b> &ndash; статическая функция удаление всего дерева или его части;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Print()</b> &ndash; дружественная функция вывода дерева (имен узлов) на экран.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>
11)</b>	Определите структуру <b>Pair</b> &ndash; пара &laquo;имя = значение&raquo; и класс <b>Pairs</b> &ndash; массив пар:</p>


<pre>
<div class="code">
struct Pair
{
	char name[21];	//имя
	int value;		//значение
};
class Pairs
{
	Pair * prs;	//массив пар
	int length;	//размер массива
	int count;	//количество имеющихся пар в массиве
	...
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите в классе <b>Pairs</b> следующие функции:</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Init()</b> &ndash; инициализация массива пар (функция получает начальный размер массива и создает массив);</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>GetValue()</b> &ndash; получить значение для заданного имени (функция должна возвратить 0 если нет такого имени и 1 в случае успеха, а значение возвращается через параметр функции, передаваемый по ссылке или указателю);</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>SetValue()</b> &ndash; установить значение для заданного имени (если такого имени в массиве нет, то добавить в массив новую пару);</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Print()</b> &ndash; дружественная функция вывода всех пар на экран.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
<b>12)</b>	Определите класс <b>Array</b> &ndash; одномерный массив вещественных чисел:</p>


<pre>
<div class="code">
class Array
{
	double * arr;	//непосредственно массив
	unsigned size;	//размер массива
	...
};
</div>
</pre>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите в классе следующие функции:</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Init()</b> &ndash; создание нового массива, размер которого передается в качестве параметра;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>DelArray()</b> &ndash; освобождение памяти занятой массивом;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Set()</b> &ndash; установить новое значение i-го элемента массива;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Get()</b> &ndash; получить значение i-го элемента массива;</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>Print()</b> &ndash; дружественная функция вывода элементов массива на экран.</p>

		
<center>[<a href="lab1.html">Предыдущая работа</a>][<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="lab3.html">Следующая работа</a>]</center>




</body>
</html>
