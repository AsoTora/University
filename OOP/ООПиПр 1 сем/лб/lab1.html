<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Лабораторная работа №1</title>
<link type="text/css" rel="stylesheet" href="style.css">
</head>
<body>
	
		
<div class="title">ЛАБОРАТОРНАЯ РАБОТА № 1</div>
		
<div class="title">ПЕРЕХОД ОТ ЯЗЫКА С К ЯЗЫКУ С++.</div>
		
<center>[<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="lab2.html">Следующая работа</a>]</center>
		
<br>
<br>
<div class="title">
<a name="0"></a>Оглавление</div>
		
<ol type="1">
			
<li>
				
<a href="#1">Цель работы</a>
			
</li>
			
<li>
				
<a href="#2">Развитие элементов языка С в С++</a>
			
</li>
			
<ul>
				
<li>
					
<a href="#2_1">Комментарии</a>
				
</li>
				
<li>
					
<a href="#2_2">Область действия объекта. Пространство имен			</a>
				
</li>
				
<li>
					
<a href="#2_3">Атрибут типа const			</a>
				
</li>
				
<li>
					
<a href="#2_4">Ссылки
			</a>
				
</li>
				
<li>
					
<a href="#2_5">Операции преобразования типа
			</a>
				
</li>
				
<li>
					
<a href="#2_6">Операции new и delete
			</a>
				
</li>
			
</ul>
			
<li>
				
<a href="#3">Функции в языке С++
			</a>
			
</li>
			
<ul>
				
<li>
					
<a href="#3_1">Перегруженные функции
			</a>
				
</li>
				
<li>
					
<a href="#3_2">Аргументы по умолчанию</a>
				
</li>
				
<li>
					
<a href="#3_3">Функции с переменным числом аргументов</a>
				
</li>
				
<li>
					
<a href="#3_4">Встраиваемые функции</a>
				
</li>
			
</ul>
			
<li>
				
<a href="#4">Индивидуальные задания</a>
			
</li>
		
</ol>
		
<br>
<br>
<div class="title">
<a name="1"></a>1.	ЦЕЛЬ РАБОТЫ</div>
		
<ol type="1">
			
<li>Знакомство с новыми возможностями языка С++ по сравнению с языком С.</li>
			
<li>Написание эффективных программ с использованием нововведений языка С++.</li>
		
</ol>
		
<br>
<br>
<div class="title">
<a name="2"></a>2.	РАЗВИТИЕ ЭЛЕМЕНТОВ ЯЗЫКА С В ЯЗЫКЕ С++</div>
		
<br>
<br>
<div class="header">
<a name="2_1"></a>2.1.	Комментарии</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Комментарии &ndash; элемент пояснения аспектов реализации программы, которые не могут быть непосредственно отражены операторами языка программирования.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Язык С++ допускает два способа записи комментариев в исходном тексте программы:</p>
		
<ul>
			
<li>символы /* начинают комментарий, который завершается символами */ (традиционно для языка С). Такие комментарии не могут быть вложенными.
		</li>
			
<li>
		символы // начинают комментарий, который завершается концом этой строки.
		</li>
		
</ul>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Символы //, /* и */ не имеют специального назначения в комментарии // и рассматриваются как обычные символы. Аналогично символы // и /* не имеют специального назначения внутри комментария /*.
		</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Примеры записи комментариев в стиле языка С:</p>
	
	
<pre>
<div class="code">
/* Декларация глобальных объектов */
int status; /* Состояние процесса */
/*
		Процедура обработки ошибок
*/
int errorhandler(int err);

Примеры записи однострочных комментариев:

// Декларация глобальных объектов
int status; // Состояние процесса

// Процедура обработки ошибок
int errorhandler(int err);
</div>
</pre>
	
		
<br>
<br>
<div class="header">
<a name="2_2"></a>2.2.	Область действия объекта. Пространство имен</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
	Объявление объекта вводит его имя в<i> область видимости</i>. Это значит, что имя может использоваться только в определенной части текста программы. Для имени, объявленного в теле функции (такое имя часто называют <i>локальным</i>), область видимости начинается с места объявления имени и заканчивается в конце <i>блока</i>, в котором это имя объявлено. Блоком называется фрагмент текста, заключенный в фигурные скобки { }.
		</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Имя называется глобальным, если оно объявлено вне любой функции, класса или пространства имен. Область видимости глобальных имен простирается от места их объявления до конца файла, содержащего объявление. Объявление имени в блоке может скрыть объявление этого имени в охватывающем блоке или глобальное имя. То есть имя может быть замещено внутри блока и будет ссылаться там на другую сущность. После выхода из блока имя восстанавливает свой прежний смысл. Например:
		</p>
	
	
<pre>
<div class="code">
int x;     // глобальная переменная x
void f1()
{
  int x;   // локальная переменная x скрывает
           // глобальную переменную x
  x = 1;   // присваивание локальной переменной x
  {
    int x; // &ldquo;скрывает&rdquo; первую локальную
           // переменную x
    x = 2; //присваивание второй локальной
           //переменной x
  }
  x = 3;   // присваивание первой локальной
           // переменной x
}
int * p = &amp;x; // взять адрес глобальной переменной x
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Сокрытие имен неизбежно при написании больших программ. Однако программист, читающий программу, может не заметить того, что какое-то имя &laquo;спряталось&raquo;. Ввиду того, что такие ошибки встречаются сравнительно редко, их очень трудно обнаружить. Поэтому следует свести к минимуму сокрытие имен.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			К скрытому глобальному имени можно обратиться с помощью оператора разрешения области видимости <i>&laquo;::&raquo;</i>. Например:</p>
	
	
<pre>
<div class="code">
int x;
void f2()
{
  int x = 1; // глобальная переменная скрыта
  ::x = 2;   // присваивание глобальной переменной x
}
}
</div>
</pre>
	
		
	Не существует способа обращения к скрытой локальной переменной.
		<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Область видимости имени начинается в точке объявления, точнее, сразу после объявителя, но перед инициализатором. Поэтому допускается использование имени в качестве инициализирующего значения для себя самого. Например:</p>
	
	
<pre>
<div class="code">
void f3()
{
  int x = x; // странно: присваиваем переменной x ее
             // собственное (неинициализированное) значение
}
</div>
</pre>
	Это допустимо, но не разумно. Хороший компилятор выдаст предупреждение в случае использования переменной до того, как она будет инициализирована.
		<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Считается, что имена аргументов функции объявлены в самом внешнем блоке функции, поэтому</p>
	
	
<pre>
<div class="code">
void f4(int x) { int x; /* ... */ }</div>
</pre>
	
		
	является ошибкой, так как переменная <i>x</i> дважды определяется в пределах одной и той же области видимости.
		<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<i>Пространство имен</i> является механизмом отражения логического группирования. То есть если некоторые объявления можно объединить по какому-либо критерию, их можно поместить в одно пространство имен для отражения этого факта. Члены пространства имен объявляются следующим образом:</p>
	
	
<pre>
<div class="code">
namespace имя_пространства_имен
{
  // объявления и определения
}

Например:

namespace A
{
  int x;
  void f1() {/*...*/}
  int f2(char * s) {/*...*/}
}
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Однако включение тел функций в объявления пространства имен затрудняет получение информации о том, какие функции предлагаются в данном пространстве, или, другими словами, затрудняют понимание <i>интерфейса</i>. Приведем пример пространства A с интерфейсом, отделенным от реализации:	</p>
	
	
<pre>
<div class="code">
namespace A
{
  int x;
  void f1();
  int f2(char * s);
}
void A::f1() {/*...*/}
int A::f2(char * s) {/*...*/}
</div>
</pre>
	
		
		Как показано в примере, член пространства имен можно объявить внутри определения пространства имен, а определить позднее, при помощи следующей записи:
	
	<pre>
<div class="code">
имя_пространства_имен::имя_члена</div>
</pre>
	
		Нельзя объявить новый член пространства имен вне его определения, используя явный <i>квалификатор</i>. Например:	
	
	<pre>
<div class="code">
void A::f3(); // ошибка: в A нет f3()</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Пространство имен является областью видимости. Поэтому<i> пространство имен</i>  является фундаментальной и относительно простой концепцией. Чем больше программа, тем полезнее становятся пространства имен для адекватного отражения логического разделения ее частей. Обычные локальные и глобальные области видимости и классы являются пространствами имен.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Обычные правила областей видимости применимы и к пространствам имен. Имя из другого пространства имен можно использовать при помощи явного указания этого пространства в качестве<i> квалификатора</i>. Например:</p>
	
	
<pre>
<div class="code">
namespace B
{
  double y;
  void f1();
}
void B::f1()
{
  A::f1();  // вызов функции f1 из пространства A
            // A &ndash; это квалификатор
  A::x = 2; // присваивание переменной x из пространства A
  y = 1.5;  // присваивание переменной y из пространства B,
            // квалификатор не нужен
}

</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Если имя используется вне пределов своего пространства имен, довольно утомительно писать каждый раз его с квалификатором. Непрерывное повторение квалификатора можно устранить <i>using</i>-объявлением, которое позволяет указать в одном месте, что x, например, находится в пространстве A. Например::</p>
	
	
<pre>
<div class="code">
void f()
{
  using A::x;
  using B::f1;

  x = 2;
  f1();
}
</div>
</pre>

	
		
<br>
<br>
<div class="header">
<a name="2_3"></a>2.3.	Атрибут типа <i>const</i>
		
</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 В С++ введена концепция определяемых пользователем <i>констант (const)</i> для указания на то, что значение нельзя изменить непосредственно. Это может быть полезно в нескольких отношениях. Например, многие объекты не меняются после инициализации; использование символических констант более удобно, чем применение литералов непосредственно в тексте программы; указатели часто используются только для чтения, но не для записи; большинство аргументов функций читаются, но не перезаписываются.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Чтобы объявить объект константой, в объявлении нужно добавить ключевое слово <i>const</i>. Так как константе нельзя присваивать значения, она должна быть инициализирована. Например:</p>
	
	
<pre>
<div class="code">
const int model = 90;         // model является константой
const int v[] = {1, 2, 3, 4}; // все v[i] являются
                              // константами
const int x;                  // ошибка: нет инициализатора
</div>
</pre>
	
	Объявление чего-либо в качестве <i>const</i> гарантирует, что в текущей области видимости его значение не изменится:
		
	
	<pre>
<div class="code">
void f1()
{
  model = 200; // ошибка
  v[2]++;      // ошибка
}
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Атрибут <i> const</i> может иметь, в частности, и возвращаемое значение функции:</p>
	
	
<pre>
<div class="code">
const char* item();
</div>
</pre>
	В этом случае становятся недопустимыми выражения вида
		
	
	<pre>
<div class="code">
item()[i] = &lsquo;a&rsquo;; // ошибка
(*item())++;     // ошибка
</div>
</pre>
	
		
	Здесь объект-константа не является статически определенным. Контроль за сохранностью объекта возлагается на компилятор.
		<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 В операциях с указателями участвуют два объекта: сам указатель и объект, на который он ссылается. Помещение ключевого слова <i>const</i> перед объявлением указателя делает константой объект, а не указатель. Для объявления самого указателя в качестве константы, используется оператор объявления <i> *const</i>, а не просто *. Например:</p>
	
	
<pre>
<div class="code">
void f2(char* p)
{
  char s[] = &ldquo;Gorm&rdquo;;
  const char* pc = s; // указатель на константу
  pc[3] = &lsquo;g&rsquo;;        // ошибка: pc указывает на константу
  pc = p;             // правильно

  char* const cp = s; // константный указатель
  cp[3] = &lsquo;a&rsquo;;        // правильно
  cp = p;             // ошибка: cp является константой

  const char* const cpc = s; // константный указатель
                             // на константу
  cpc[3] = &lsquo;a&rsquo;; // ошибка
  cpc = p;      // ошибка
}
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Некоторый объект при обращении к нему через один указатель может быть константой, а при обращении через другой &ndash; переменной. Это свойство особенно полезно для аргументов функций. Объявив аргумент-указатель константой, функция не сможет изменить объект, на который он ссылается. Например:</p>
	
	
<pre>
<div class="code">
// нельзя изменить q
char* strcpy(char* p, const char* q);
</div>
</pre>
	
		Можно присвоить адрес переменной указателю на константу, потому что это безвредная операция. Нельзя, однако, присвоить адрес константы произвольному указателю, потому что в этом случае можно будет изменить значение объекта. Например:
	
	<pre>
<div class="code">
void f3()
{
  int a = 1;
  const int c = 2;
  const int* p1 = &amp;c; // правильно
  const int* p2 = &amp;a; // правильно
  int* p3 =&amp;c;       // ошибка: инициализация int*
                      // значением типа const int*
  *p3 = 7;            // попытка изменить значение
                      // константы c
}
</div>
</pre>
	
		
	При помощи явного преобразования типа можно устранить ограничение, состоящее в том, что указатель указывает на константу.
		<br>
<br>
<div class="header">
<a name="2_4"></a>2.4.	Ссылки</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<i>Ссылка (reference)</i> является альтернативным именем объекта. Ссылки чаще всего используются для указания аргументов функций и возвращаемых значений вообще, и при перегрузке операторов в частности. Запись <i>X&amp;</i> означает ссылку на <i>X</i>. Например:</p>
	
	
<pre>
<div class="code">
void f1()
{
  int i = 1;
  int&amp; r = i;  // r и i ссылаются на одно и то же целое
  int x = r;   // x = 1

  r = 2;       // i = 2;
}
</div>
</pre>
	
		Чтобы быть уверенным, что ссылка является именем чего-либо, ее необходимо инициализировать. Например:
	
	<pre>
<div class="code">
int i = 1;
int&amp; r1 = i;     // правильно
int&amp; r2;         // ошибка: отсутствует инициализатор
extern int&amp; r3;  // правильно &ndash; r3 инициализирована в
                 // другом месте
</div>
</pre>
	
		Инициализация ссылки кардинально отличается от присваивания ей значения. Несмотря на форму записи, ни один оператор не выполняет действий над ссылкой. Например:
	
	<pre>
<div class="code">
void f2()
{
  int ii = 0;
  int&amp; rr = ii;
  rr++;           // ii увеличивается на 1
  int* pp = &amp;rr;  // pp указывает на ii
}
</div>
</pre>
	
		Как следствие, значение ссылки нельзя изменить после инициализации. Она всегда ссылается на объект, которым инициализирована.
		<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Ссылка может использоваться в качестве аргумента функции, которая изменяет значение передаваемого ей объекта. Например:</p>
	
	
<pre>
<div class="code">
void increment(&amp; aa) { aa++; }
void f3()
{
  int x = 1;
  increment(x);  // x = 2
}
</div>
</pre>
	Семантика передачи аргументов тождественна семантике инициализации, поэтому после вызова <i>increment</i> его аргумент <i>aa </i>становится другим именем для <i>x</i>.
		<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Представим эту же программу без использования понятия ссылки. С точки зрения удобочитаемости исходного текста программы предпочтительнее явно возвращать значение функции:
		</p>
	
	
<pre>
<div class="code">
int next(int aa) { return aa + 1; }
void f3()
{
  int x = 1;
  x = next(x);  // x = 2
}
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Аналогичный результат достигается при использовании в качестве аргумента указателя на изменяемую переменную:</p>
	
	
<pre>
<div class="code">
void incr (int* aa) { (*aa)++; }
void f3()
{
  int x = 1;
  incr(&amp;x);  // x = 2
}
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Ссылки удобно применять для определения функций, которые могут использоваться как в левой, так и  в правой части операции присваивания. Такая возможность реализуется посредством возврата функцией результата ссылочного типа.</p>
		
<br>
<br>
<div class="header">
<a name="2_5"></a> 2.5.	Операции преобразования типа</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Операции над объектами разных типов порождают  вопрос  корректности и типа результата. В языках С и С++ допустимы операции над любыми комбинациями арифметических типов (<i>int, short, long, unsigned int, unsigned short, unsigned long, float, double</i>). Символы <i>(char,  unsigned char</i>) преобразуются к типу <i>int</i>. Результат  арифметической  операции  в  математическом отношении будет корректным в рамках конкретных аппаратных возможностей. Например:</p>
	
	
<pre>
<div class="code">
unsigned char x = 150, y = 128;
unsigned char z = x + y;         // z!=150+128
int  a = x + y;                  // a==150+128
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Корректными и прогнозируемыми являются операции сложения  и вычитания над парами операндов (<i>указатель_обьекта_типа_X &ndash; арифметическое_значение</i>), а также вычитания указателей обьектов одного типа).</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Язык С предоставляет пользователю операцией <i>приведения</i> типа (<i>тип</i>)<i>X</i> явно указать требуемый вид преобразования объекта <i>X</i>::</p>
	
	
<pre>
<div class="code">
// процедура печати 10 случайных чисел в диапазоне 0...1
void main(void)
{
  static n = 32767;
  for (int i = 0; i &lt; 10; i++)
    printf("\n %f",(float)random(n)/(float)n);
}
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Потребность в операции приведения возникают в случае появления неопределенности типа операнда и при необходимости обхода запретов языка на комбинации операндов.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Неопределенность типа операнда возникает, например, при передаче значения аргумента функции при отсутствии в ее описании описания списка параметров. Компилятор предупреждает программиста о подобных ситуациях, но иногда неопределенность порождена отсутствием достаточной информации.
</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Рассмотрим пример программы с неопределенностью связи аргумент - параметр.
</p>
	
	
<pre>
<div class="code">
void main()
{
  float f = 125.0;

// Надежда на интеллект компилятора
  printf("\n??? %f %d %x %f", f, f, f, f);

// На компилятор надейся, но приводи тип в соответствие
  printf("\n*** %f %d %x %f", f, (int)f, (int)f, f);
}



Результаты работы программы (Borland C++):

??? 125.000000 0 0 0.000000
*** 125.000000 125 7d 125.000000
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Источником ошибок при вычислении выражения может быть неправильное представление промежуточных результатов. Пусть необходимо установить способ представления в памяти конкретной вычислительной системы чисел типа <i>long</i>:</p>
	
	
<pre>
<div class="code">
void main()
{
  long lx = 0;

// Заполнение байтов поля типа long значениями
// степени весовых коэффициентов
  for (int i=0; i&lt;sizeof(lx); i++)
    lx|=((long)i)&lt;&lt;(i&lt;&lt;3); // Здесь приведение необходимо для
                           // правильности результата

// Отображение представления поля типа long
// Здесь приведение типа требует компилятор
  unsigned char* x = (unsigned char*)&amp;lx;

  printf("\nРазмер %d, значение %0*lx, представление ",
         sizeof(lx), sizeof(lx)&lt;&lt;1, lx);

  for (i=0; i&lt;sizeof(lx); i++)
    printf(" %02x", x[i]);
}
</div>
</pre>
	
		Результат работы программы на ПЭВМ класса IBM PC XT/AT:
	
	<pre>
<div class="code">
	Размер 4, значение 03020100, представление 00 01 02 03
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Примеры запрещенных видов операции присваивания:</p>
		
<ul>
			
<li>
				
<i>указатель = арифметическое_значение;</i>
			
</li>
			
<li>
				
<i>арифметическая_переменная = указатель;</i>
			
</li>
			
<li>
				
<i>указатель_обьекта_типа_1 = указатель_обьекта_типа_2, </i>если<i>
(тип_1 != тип2) &amp;&amp; (тип_1 != void) &amp;&amp; (тип_2 != void).</i>
			
</li>
		
</ul>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			В языке С++ допустимы два способа  записи  операции  явного преобразования типа:</p>
		
<ul>
			
<li>	традиционная для языка C запись операции приведения типа в форме <i>(тип)выражение</i>, например:</li>
		
</ul>
	
	
<pre>
<div class="code">
(float)i;     // приведение простой переменной
(long)(x+y);  // приведение значения выражения
(char *)&amp;x;   // приведение значения адреса
(int *)0x100; // приведение значения константы
</div>
</pre>
	
		
<ul>
			
<li>	функциональная запись операции приведения типа в форме <i>тип(выражение)</i>, где <i>тип</i> должен обозначаться простым именем, например:</li>
		
</ul>
	
	
<pre>
<div class="code">
float(i),     // int i;
long(x + y),    // int x,y;
double(125);  // int z=125;
</div>
</pre>
	
		Ограничение на имя типа легко преодолеть определением нового имени типа. Например, оператор декларации:
	
	<pre>
<div class="code">
char* p = (char*)0777; // традиционное приведение </div>
</pre>
	
		
		в функциональной форме записи операции приведения типа можно представить следующим образом:	
	
	<pre>
<div class="code">
typedef char* string;   // идентификация типа char*
                        // новым именем string
char* p = string(0777); // функциональное приведение к типу
                        // string (либо обращение
                        // к функции string?)
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Функциональная запись улучшает читаемость текста программы. Например, рассмотрим эквивалентные выражения:</p>
	
	
<pre>
<div class="code">
marker pn = base(xn-&gt;tp)-&gt;buf;   // функциональная запись
marker pn = ((base)xn-&gt;tp)-&gt;buf; // традиционная запись
</div>
</pre>
	
		
		Операция -&gt; имеет больший приоритет, чем приведение, поэтому последнее выражение интерпретируется как
	
	<pre>
<div class="code">
marker pn = ((base)(xn-&gt;tp))-&gt;buf; // здесь 3 пары скобок!
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Функциональный стиль  записи  операции  приведения особенно удобен в С++ для  определяемых  пользователем  типов  (классов). Операция  приведения в этом случае реализуется процедурой создания объекта - конструктором (имя процедуры  совпадает  с  именем типа, а набор параметров характеризует исходное состояние объекта).</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Явное приведение  типов указателей позволяет получить адрес объекта любого типа:</p>
	
	
<pre>
<div class="code">
any_type* p = (any_type*)&amp;some_object;</div>
</pre>
	
		
	Известное значение указателя <i>p</i> позволяет работать с некоторым объектом <i>some_object</i> как объектом типа <i>any_type</i> (см. пример программы вывода представления поля типа <i>long</i>).
		<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Явное преобразование типов рекомендуется использовать  лишь в крайних случаях. Появление неожиданных результатов операций во внешне правильных выражениях и исходных данных - сигнал для анализа и коррекции хода преобразований.</p>
		
<br>
<br>
<div class="header">
<a name="2_6"></a>2.6.	Операции <i>new</i> и <i>delete</i>
		
</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Любой именованный объект программы размещается в статически либо автоматически  распределяемой памяти. Статический объект размещается во время запуска программы и существует в течение всего времени ее выполнения. Автоматический объект  размещается каждый раз при входе в его блок и существует только до момента выхода из блока.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Часто возникает потребность управляемого размещения объектов в памяти в соответствии с алгоритмом решения задачи  без привязки к блокам программы. В языках С и С++ такие объекты могут адресоваться только косвенно по значению указателя. Указатель может иметь при этом имя, но адресуемый им объект является безымянным.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Управление размещением объектов осуществляется операциями захвата и освобождения памяти. В языке С для этих целей приходится пользоваться библиотечными функциями. Например, в файле <i>alloc.h</i> декларированы функции:</p>
	
	
<pre>
<div class="code">
	void* malloc(unsigned nbytes); // возврат указателя
// на выделеную область размером nbytes (NULL при
// недостатке памяти  или nbytes==0)

void free(void* block_pointer); // освобождение
// захваченной памяти по заданному адресу.

	</div>
</pre>
	
		Операции захвата и освобождения памяти в стиле языка С имеют вид:
	
	<pre>
<div class="code">указатель_на_обьект = malloc(sizeof(атрибут_типа_объекта));
free(указатель_на_объект);
	</div>
</pre>
	
		В языке С++ операция захвата памяти записывается в  следующих видах:
	
	<pre>
<div class="code">
	указатель_на_объект = new атрибуты_типа_объекта;

указатель_на_объект = new атрибуты_типа_объекта(значение);
</div>
</pre>
	
		(здесь <i>значение</i> определяет начальное значение создаваемого объекта для некоторых типов данных).
		<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Результат операции  захвата  памяти - значение указателя на выделенную для размещения объекта указанного типа область  памяти. Признак нехватки памяти - пустое значение указателя (<i>0</i> или <i>NULL</i>).</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Примеры программирования захвата памяти:</p>
	
	
<pre>
<div class="code">
int* x;
char* y;
char* z = "abcdef";
// ...
x = new int;                 // создание простого объекта
y = new char[sizeof(z) + 1]; // создание массива символов
// ...
float* s = new float[n];  // создание массива из n элементов
int* d = new int(-12345); // создание и инициализация объекта

</div>
</pre>
	
		
Схема выполнения последнего оператора:
	
	<pre>
<div class="code">
int* d = new int;  // создание объекта &ndash; захват памяти
*d = int(-12345);  // конструирование конкретного объекта
</div>
</pre>
	
		Очевидно, что массивы объектов подобным инициализироваться не могут.
		<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Созданный с помощью операции <i>new</i> объект существует до завершения программы, если не использована операция освобождения памяти <i>delete</i> (сказанное справедливо и для объектов, создаваемых библиотечными функциями).
</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Виды записи операции освобождения памяти:</p>
	
	
<pre>
<div class="code">delete указатель_на_объект;
delete[размер] указатель_на_объект;
</div>
</pre>
	(вторая форма применяется для определяемых пользователем векторных типов данных, а для остальных типов данных параметр размер игнорируется).
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Операция <i>delete</i> может применяться только к указателю, который был возвращен операцией <i>new</i>. Повторное освобождение памяти чревато аварийными последствиями. После освобождения памяти можно присвоить указателю нулевое значение, так как применение <i>delete</i> к нулю не вызывает никаких действий.
</p>
		
<br>
<br>
<div class="title">
<a name="3"></a>3.	ФУНКЦИИ В ЯЗЫКЕ С++</div>
		
<br>
<br>
<div class="header">
<a name="3_1"></a>3.1.	Перегруженные функции</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Как правило, разным функциям дают различные имена, но когда функции выполняют концептуально аналогичные задачи для объектов различных типов, может оказаться удобным присвоить им одно и то же имя. Использование одного имени для операции, выполняемой с различными типами, называется <i>перегрузкой</i>. Такая техника уже используется для базовых операций С++. Например, существует только одно имя для сложения +, но его можно использовать для сложения целых, чисел с плавающей точкой и для инкремента указателей. Эту идею легко распространить на функции, определяемые пользователем. Например:</p>
	
	
<pre>
<div class="code">void print(int a);          // печать целого
void print(const char* s);  //печать символьной строки
</div>
</pre>
	
		С точки зрения компилятора, единственное, что функции имеют общего между собой &ndash; это имена. Перегруженные функции предназначены в первую очередь для удобства записи. Когда вызывается функция f, компилятор определяет, какую из функций с именем f использовать. Идея состоит в том, чтобы использовать функцию с наиболее подходящими аргументами и выдать сообщение об ошибке, если таковой не найдено. Например:
	
	<pre>
<div class="code">void print(double);
void print(long);

void f()
{
  print(1L);   // print(long)
  print(1.0);  // print(double)
  print(1);    // ошибка: двусмысленно &ndash; print(long(1))
               // или print(double(1))
}
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Процесс поиска подходящей функции из множества перегруженных заключается в нахождении наилучшего соответствия типов формальных и фактических аргументов (такой процесс часто называют <i>разрешением перегрузки</i>). Это осуществляется путем проверки набора критериев в следующем порядке:</p>
		
<ul>
			
<li>точное соответствие типов; то есть полное соответствие или соответствие, достигаемое тривиальными преобразованиями типов;</li>
			
<li>соответствие, достигаемое &laquo;продвижением&raquo; интегральных типов (например, <i>bool</i> в <i>int</i>, <i>char</i> в <i>int</i>, <i>short</i> в <i>int</i> и в их <i>unsigned</i> аналоги, <i>float</i> в <i>double</i>, <i>double</i> в <i>long double</i>);</li>
			
<li>	соответствие, достигаемое путем стандартных преобразований (например,<i> int</i> в <i>double</i>, <i>double</i> в<i> int</i>, указателей на производные типы в указатели на базовые, указателей на произвольные типы в <i>void*</i>,<i> int</i>, <i>unsigned int</i>);</li>
			
<li>	соответствие, достигаемое при помощи преобразований определяемых пользователем.</li>
		
</ul>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Если соответствие может быть получено двумя способами на одном и том же уровне критериев, вызов считается неоднозначным и отвергается. Такой подход отражает правила С и С++ для встроенных числовых типов. Например:</p>
	
	
<pre>
<div class="code">void print(int);
void print(const char*);
void print(double);
void print(long);
void print(char);

void h(char c, short s, float f)
{
  print(c);    // точное соответствие; print(char)
  print(i);    // точное соответствие; print(int)
  print(s);    // интегральное &laquo;продвижение&raquo;; print(char)
  print(f);    // продвижение float в double; print(char)
  print(&lsquo;a&rsquo;);  // точное соответствие; print(char)
  print(49);   // точное соответствие; print(int)
  print(0);    // точное соответствие; print(int)
  print(&ldquo;a&rdquo;);  //точное соответствие; print(const char*)
}
</div>
</pre>
	
		Результат разрешения перегрузки не зависит от порядка объявления функций.
		<br>
<br>
<div class="header">
<a name="3_2"></a>3.2.	Аргументы по умолчанию</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			В общем случае у функции может быть больше аргументов, чем в самых простых и наиболее часто используемых случаях. В частности, это свойственно функциям, создающим объекты. Для более гибкого использования этих функций иногда применяются необязательные аргументы. Рассмотрим в качестве примера функцию печати целого числа. Вполне разумно предоставить пользователю возможность выбора основания счисления печатаемого числа, хотя в большинстве случаев числа будут печататься как десятичные целые значения. Следующая функция</p>
	
	
<pre>
<div class="code">void print (int value, int base = 10);

void f()
{
  print(31);
  print(31,10);
  print(31,16);
  print(31,2);
}
</div>
</pre>
	
		напечатает такие числа:
	
	<pre>
<div class="code">31	31	1f	11111</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Того же самого результата можно было добиться при помощи перегруженных функций:</p>
	
	
<pre>
<div class="code">void print(int value, int base);
inline void print(int value) { print(value,10); }
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Однако в последнем варианте текст программы не столь явно демонстрирует желание иметь одну функцию <i>print</i>, но при этом обеспечить удобную и краткую форму записи.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Тип аргумента по умолчанию проверяется в месте объявления функции, а значение этого параметра вычисляется в момент вызова функции. Задавать аргументы по умолчанию можно только в конце списка аргументов. Например:</p>
	
	
<pre>
<div class="code">int f(int, int =0, char* =0);  // правильно
int g(int =0, int =0, char*);  // ошибка
int h(int =0, int, char* =0);  // ошибка
</div>
</pre>
	
		В данном контексте наличие пробела между символами * и = весьма существенно, поскольку *= является операцией присваивания
	
	<pre>
<div class="code">int nasty(char*=0);  // синтаксическая ошибка</div>
</pre>
	
		Аргумент по умолчанию не может быть повторен или изменен в последующих объявлениях в той же области видимости. Например:
	
	<pre>
<div class="code">void f(int x = 7);
void f(int x = 7);   // ошибка: нельзя повторять
                     // аргумент по умолчанию
void f(int x = 8);   // ошибка: другое значение
                     // аргумента по умолчанию 
void g()
{
  void f(int x = 9); // правильно: это объявление
                     // скрывает предыдущее
}
</div>
</pre>
	
		
<br>
<br>
<div class="header">
<a name="3_3"></a>3.3.	Функции с переменным числом аргументов</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Существуют функции, в описании которых невозможно указать число и типы всех допустимых аргументов. Тогда список аргументов завершается многоточием <i>(...)</i>, что означает "<i>и, возможно, еще несколько аргументов</i>". Например:</p>
	
	
<pre>
<div class="code">int printf(const char* ...);</div>
</pre>
	
		При вызове <i>print</i>f обязательно должен быть указан параметр типа <i>char*</i>, однако могут быть (а могут и не быть) еще другие аргументы. Например:
	
	<pre>
<div class="code">printf("Hello, world\n");
printf("My name is %s %s", first_name, second_name);
printf("%d + %d = %d\n", 2, 3, 5);
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Такие функции пользуются для распознавания своих фактических аргументов недоступной компилятору информацией. В случае функции <i>printf</i> первый аргумент является строкой, специфицирующей формат вывода. Она может содержать специальные символы, которые позволяют правильно воспринять последующие аргументы. Например, <i>%s</i> означает &ndash; "<i>будет фактический аргумент типа char*</i>", <i>%d</i> означает &ndash; "<i>&gt;будет фактический   аргумент типа int</i>". Но компилятор этого не знает, и поэтому он не может убедиться, что объявленные аргументы действительно присутствуют в вызове и имеют соответствующие типы. Например, следующий вызов</p>
	
	
<pre>
<div class="code">printf("My name is %s %s\n", 2);</div>
</pre>
	
		нормально откомпилируется, но, в лучшем случае, распечатает нечто странное.
		<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Очевидно, что раз аргумент не объявлен, то компилятор не имеет сведений для контроля и стандартных преобразований типа этого аргумента. Поэтому char или short передаются как <i>int</i>, а <i>float</i> как <i>double</i>, хотя пользователь, возможно, имел в виду другое.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			В хорошо продуманной программе может потребоваться, в виде исключения, лишь несколько функций, в которых указаны не все типы аргументов. Чтобы обойти контроль типов аргументов, лучше использовать перегрузку функций или аргументы по умолчанию, чем аргументы, типы которых не были объявлены. Многоточие становится необходимым только тогда, когда могут меняться не только типы, но и число аргументов.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Есть стандартный набор макроопределений, находящийся в <i>stdarg.h</i>, для выбора необъявленных аргументов. Рассмотрим функцию реакции на ошибку, первый параметр которой показывает степень тяжести ошибки. За ним может следовать произвольное число строк. Нужно составить сообщение об ошибке с учетом, что каждое слово из него передается как отдельная строка:</p>
	
	
<pre>
<div class="code">extern void error(int ...)
extern char* itoa(int, char[]);

void main(int argc, char* argv[])
{
  switch (argc)
  {
    case 1:
      error(0, argv[0], (char*)0);
      break;
    case 2:
      error(0, argv[0], argv[1], (char*)0);
      break;
    default:
      char buff[8];
      error(1, argv[0], "With",itoa(argc-1, buff),
            "arguments", (char*)0);
  }
  // ...
}
</div>
</pre>
	
		Функция <i>itoa</i> возвращает строку символов, представляющую ее целый аргумент. Приведение <i>0</i> к <i>(char*)0</i> необходимо потому, что sizeof(int) не обязано совпадать с <i>sizeof(char*)</i>. Функцию реакции на ошибку можно определить так:.
	
	<pre>
<div class="code">#include &lt;stdarg.h&gt;
void error(int severity ...)
// за "severity" (степень тяжести ошибки) следует
// список строк, завершающийся нулем
{
  va_list ap;
  va_start(ap, severity); // начало параметров

  for(;;)
  {
    char* p = va_arg(ap,char*);
    if (p == 0) break;
    cerr &amp;lt;&amp;lt; p &amp;lt;&amp;lt; ' ';
  }
  va_end(ap);             // очистка параметров
  cerr &amp;lt;&amp;lt; '\n';
  if(severity) exit(severity);
}
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Вначале при вызове <i>va_start()</i> определяется и инициализируется <i>va_list</i>. Параметрами макроопределения <i>va_start</i> являются имя переменной типа <i>va_list</i> и последний формальный аргумент. Для выборки по порядку неописанных аргументов используется макроопределение <i>va_arg()</i>. В каждом обращении к <i>va_arg</i> нужно задавать тип ожидаемого фактического аргумента. В <i>va_arg() </i>предполагается, что аргумент такого типа присутствует в вызове, но обычно нет возможности проверить это. Перед выходом из функции, в которой было обращение к <i>va_start</i>, необходимо вызвать <i>va_end</i>. Причина в том, что в <i>va_start()</i> могут быть такие операции со стеком, из-за которых корректный возврат из функции становится невозможным. В <i>va_end()</i> устраняются все нежелательные изменения стека.</p>
		
<br>
<br>
<div class="header">
<a name="3_4"></a>3.4.	Встраиваемые функции</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Функцию можно определить со спецификатором <i>inline</i>. Такие функции называются <i>встроенными</i>. Например:</p>
	
	
<pre>
<div class="code">inline factor(int n) { return (n&lt;2)?1:n*factor(n-1); }</div>
</pre>
	
		Спецификация <i>inline</i> служит подсказкой компилятору, что вызов функции <i>factor</i> можно реализовать подстановкой ее тела, а не с помощью обычного механизма вызова функций. Хороший оптимизирующий компилятор вместо генерации вызова <i>factor(6)</i> может просто использовать константу 720. Из-за наличия взаимно рекурсивных вызовов встроенных функций, а также встроенных функций, рекурсивность которых зависит от входных данных, нельзя утверждать, что каждый вызов встроенной функции действительно реализуется подстановкой ее тела. Степень оптимизации, проводимой компилятором, нельзя формализовать, поэтому одни компиляторы создадут команды <i>6*5*4*3*2*1</i>, другие &ndash;<i> 6*factor(5)</i>, а некоторые ограничатся не оптимизированным вызовом <i>factor(6)</i>.
		<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Чтобы реализация вызова подстановкой стала возможна даже для не слишком развитых систем программирования, нужно, чтобы не только определение, но и описание встроенной функции находилось в текущей области видимости. В остальном спецификация <i>inline</i> не влияет на семантику вызова.</p>
		
<br>
<br>
<div class="title">
<a name="4"></a>4.	ИНДИВИДУАЛЬНЫЕ ЗАДАНИЯ</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Для всех вариантов заданий:</p>
		
<ul>
			
<li>определить типы и функции в соответствии с вариантом задания;</li>
			
<li>в функции <b>main()</b> реализовать демонстрацию работы созданных функций;</li>
		
</ul>
		
<br>
<br>
<div class="header">
<a name="|||||"></a>ЗАМЕЧАНИЯ:</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
				Весь ввод/вывод должен осуществляться только внутри функции <b>main()</b>. Если в функции необходимо передавать объекты типа структура, то передавать их следует через указатель либо ссылку на объект.
</p>
		
<br>
<br>
<div class="header">
<a name="|||||"></a>Варианты заданий</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>
1)</b>	Определите структуру <b>Date</b> для хранения даты:</p>
	
	
<pre>
<div class="code">
struct Date
{
	unsigned y;	//год
	unsigned m;	//месяц
	unsigned d;	//день
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите функции, которые читают дату из потока ввода, выводят дату. Определите функцию (с параметрами по умолчанию), которая добавляет день, месяц или год к дате. Определите функцию, которая вычисляет разницу в днях между двумя датами.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>
2)</b>	Определите структуру <b>Time</b> для хранения времени:</p>
	
	
<pre>
<div class="code">
struct Time
{
	unsigned h;	//часы
	unsigned m;	//минуты
	unsigned s;	//секунды
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите функции, которые читают время из потока ввода, выводят время. Определите функцию (с параметрами по умолчанию), которая добавляет часы, минуты или секунды ко времени. Определите функцию, которая возвращает количество секунд прошедших от <b>time1</b> до <b>time2</b>.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>
3)</b>	Определите функцию <b>MyPrintf()</b>, получающую printf-подобную строку форматирования, которая может содержать директивы: <b>%c</b> (символ), <b>%s</b> (строка), <b>%d </b>(целое типа <b>int</b>) или <b>%f</b> (вещественное типа <b>double</b>), и произвольное количество других аргументов. Не пользуйтесь функцией <b>printf()</b>. Используйте макросы определенные в <b>&lt;stdarg.h&gt;</b>.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>4)</b>	Имеется узел бинарного дерева:</p>
	
	
<pre>
<div class="code">
struct Node
{
	char name[10];	//имя узла
	Node * left;		//левая ветвь
	Node * right;		//правая ветвь
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите функцию добавления новых узлов в дерево <b>AddNode()</b> и функцию удаления дерева <b>DelTree()</b>.Определите рекурсивную функцию вывода такого дерева <b>PrintTree()</b> на экран.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>
5)</b>	Имеется элемент односвязного списка:</p>
	
	
<pre>
<div class="code">
struct List
{
	void * data;	//указатель на данные
	List * next;	//указатель на следующий элемент
}
* head;			//указатель на начало списка
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите следующие функции: <b>Add()</b> &ndash; добавление нового элемента в начало или конец списка (предусмотреть обе возможности), <b>PrintList()</b> &ndash; вывод содержимого списка на экран и <b>Delete()</b> &ndash; удалить i-й элемента из списка.

</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>6)</b>	Имеется элемент стека (дисциплина обслуживания LIFO):</p>
	
	
<pre>
<div class="code">
struct Stack
{
	void * data;	//указатель на данные
	Stack * prev;	//указатель на предыдущий элемент
}
* top;			//указатель на вершину стека
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите следующие функции: <b>Push()</b> &ndash; поместить данные в стек, <b>Pop()</b> &ndash; извлечь данные из стека (при этом элемент удаляется из стека), <b>PrintStack()</b> &ndash; вывод на экран содержимого стека.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>
7)</b>	Бинарное дерево называется сбалансированным тогда и только тогда, когда высоты двух его поддеревьев отличаются не более чем на единицу. Используя описание узла дерева из задания 4 определите рекурсивную функцию <b>TreeHeight()</b>, которая вычисляет высоту дерева. Высота дерева, состоящего из единственного узла равна 0. Если узел имеет ветви, то высота такого дерева вычисляется следующим образом:</p>
		
<ul>
			
<li>
высота = 1 + max(высота_левого_поддерева, высота_правого_поддерева)</li>
			
<li>Определите функцию <b>IsBalancedTree()</b>, которая возвращает 1 если дерево сбалансировано и 0 в противном случае.</li>
		
</ul>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>8)</b>	Имеется элемент очереди (дисциплина обслуживания FIFO):</p>
	
	
<pre>
<div class="code">
struct Queue
{
	void * data;	//указатель на данные
	Queue * next;	//указатель на следующий элемент очереди
} * begin;		//указатель на начало очереди
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите следующие функции: <b>Put()</b> &ndash; поместить элемент в конец очереди, <b>Get()</b> &ndash; извлечь элемент из очереди (при этом элемент удаляется из очереди), <b>PrintQueue()</b> &ndash; вывод на экран содержимого очереди.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>
9)</b>	Определите структуру <b>Complex</b> для хранения комплексных чисел:</p>
	
	
<pre>
<div class="code">
struct Complex
{
	double re;	//вещественная часть
	double im;	//мнимая часть
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите следующие функции: <b>Add()</b>, <b>Sub()</b>, <b>Mul()</b>, <b>Div()</b> &ndash; сложение, вычитание, умножение и деление комплексных чисел. Все функции должны возвращать ссылку на новое комплексное число, содержащее результат операции. Определите функцию <b>PrintComplex()</b> для вывода значения комплексного числа на экран в алгебраической или показательной формах.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>
10)</b>	 Определите структуру TreeNode &ndash; узел дерева:</p>
	
	
<pre>
<div class="code">
struct TreeNode
{
	char * name;		//имя узла
	TreeNode * nodes;	//список дочерних узлов
	TreeNode * next;	//следующий узел на том же уровне
}
* root;	//корневой узел (первый узел на нулевом уровне)
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите следующие функции: <b>AddNode()</b> &ndash; добавление нового дочернего узла, <b>FindNode()</b> &ndash; поиск узла по его имени, <b>DelTree()</b> &ndash; удаление всего дерева, <b>PrintTree()</b> &ndash; вывод дерева (имен узлов) на экран.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>
 
11)	</b>  Определите структуру <b>Pair</b> &ndash; пара &laquo;имя = значение&raquo; и структуру<b> Pairs</b> &ndash; массив пар:</p>
	
	
<pre>
<div class="code">
struct Pair
{
	char * name;	//имя
	int value;	//значение
};
#define MAX_PAIRS 100
struct Pairs
{
	Pair p[MAX_PAIRS];	//массив пар
	int count;		//количество пар в массиве
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите следующие функции для работы с массивом: <b>GetValue()</b> &ndash; получить значение для заданного имени (функция должна возвратить 0 если нет такого имени и 1 в случае успеха, а значение возвращать через параметр функции, передаваемый по ссылке или указателю), <b>SetValue()</b> &ndash;установить значение для заданного имени (если такого имени в массиве нет, то добавить в массив новую пару), <b>PrintPairs()</b> &ndash; вывод всех пар на экран.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>
12)</b>  Определите структуру Array &ndash; одномерный массив вещественных чисел:</p>
	
	
<pre>
<div class="code">
struct Array
{
	double * vec;		//непосредственно вектор
	unsigned size;	//размер вектора
	int last;			//индекс последнего элемента
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите следующие функции: <b>NewArray()</b> &ndash; создание нового массива, размер которого передается в качестве параметра. Функция возвращает указатель на новый массив, <b>DelArray()</b> &ndash; полное освобождение памяти занятой массивом, <b>Add()</b> &ndash; добавление нового значения в массив, <b>Del()</b> &ndash; удаление из массива i-го элемента, <b>Print()</b> &ndash; вывод элементов массива на экран.</p>
		
<center>[<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="lab2.html">Следующая работа</a>]</center>
	

</body>
</html>
