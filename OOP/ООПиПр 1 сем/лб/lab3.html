<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Лабораторная работа №3</title>
<link type="text/css" rel="stylesheet" href="style.css">
</head>
<body>
	
		
<div class="title">ЛАБОРАТОРНАЯ РАБОТА №3</div>
		
<div class="title">ОБЪЕКТЫ КЛАССОВ</div>
		
<center>[<a href="lab2.html">Предыдущая работа</a>][<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="lab4.html">Следующая работа</a>]</center>
		
<br>
<br>
<div class="title">
<a name="0"></a>Оглавление</div>
		
<ol type="1">
			
<li>
				
<a href="#1">Цель работы</a>
			
</li>
			
<li>
				
<a href="#2">Конструирование и уничтожение объектов</a>
			
</li>
			
<ul>
				
<li>
					
<a href="#2_1">Конструкторы
			</a>
				
</li>
				
<li>
					
<a href="#2_2">Деструкторы</a>
				
</li>
				
<li>
					
<a href="#2_3">Конструкторы по умолчанию</a>
				
</li>
				
<li>
					
<a href="#2_4">Конструкторы вложенных классов</a>
				
</li>
				
<li>
					
<a href="#2_5">Конструирование массивов объектов</a>
				
</li>
				
<li>
					
<a href="#2_6">Конструирование статических объектов</a>
				
</li>
				
<li>
					
<a href="#2_7">Копирование объектов</a>
				
</li>
			
</ul>
			
<li>
				
<a href="#3">Индивидуальные задания</a>
			
</li>
		
</ol>
		
<br>
<br>
<div class="title">
<a name="1"></a>1.	ЦЕЛЬ РАБОТЫ</div>
		
<ol type="1">
			
<li>Изучение основных правил определения и переопределения конструкторов и деструкторов объектов классов.</li>
			
<li>Использование конструкторов и деструкторов для функционального замыкания объектов программы.</li>
			
<li>Изучение особенностей конструирования элементов массивов и статических объектов.</li>
		
</ol>
		
<br>
<br>
<div class="title">
<a name="2"></a>2.	КОНСТРУИРОВАНИЕ И УНИЧТОЖЕНИЕ ОБЪЕКТОВ</div>
		
<div class="title"><a name="2_1">2.1.Конструкторы</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Использование функций типа <i>init()</i> для инициализации объектов класса неэлегантно и подвержено ошибкам. Так как нигде не сказано, что объект должен быть проинициализирован, программист может забыть об этом, или сделать это дважды (часто с одинаково разрушительными последствиями). Лучшим подходом является предоставление программисту возможности объявить функцию, имеющую явное назначение &ndash; инициализация объектов. Ввиду того, что такая функция создает (конструирует) значения данного типа, она называется <i>конструктором</i>. Конструктор распознается по имени, которое совпадает с именем самого класса. </p>
		Например:
	
	<pre>
<div class="code">
class Date
{
  // ...
public:
  Date(int, int, int);
};

Date::Date(int dd, int mm, int yy)
{
  d = dd;
  m = mm;
  y = yy;
}
</div>
</pre>
	
		
Если класс имеет конструктор, все объекты этого класса будут проинициализированы. Если конструктору требуются аргументы, они должны быть предоставлены:
	
	<pre>
<div class="code">
Date today = Date(23, 6, 1983);
Date xmas(25, 12, 1990); // сокращенная форма
Date my_birthday;        // ошибка: отсутствует инициализация
</div>
</pre>
	
		
Часто удобно иметь несколько способов инициализации объекта класса. Этого можно добиться, введя несколько конструкторов. Например:
	
	<pre>
<div class="code">
class Date
{
  // ...
public:
  Date(int, int, int); // день, месяц, год
  Date(int, int);      // день, месяц, текущий год
  Date(int);           // день, текущие месяц и год
  Date();              // дата по умолчанию - сегодня
  Date(const char*);   // дата в строковом представлении
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Конструкторы подчиняются тем же правилам разрешения перегрузки, что и остальные функции (лаб. раб. №1). Компилятор сам выбирает конструктор в каждом конкретном случае:</p>
	
	
<pre>
<div class="code">
Date today(4);
Date july4(&ldquo;July 4, 1983&rdquo;);
Date now;        // инициализация по умолчанию текущей датой
.	</div>
</pre>
	
		
<div class="title"><a name="2_2">	2.2.	Деструкторы</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Конструкторы инициализируют объект. Другими словами, они создают среду, в которой работают функции-элементы. Иногда создание такой среды подразумевает захват каких-то ресурсов, &ndash; таких как файл, блокировка или память, которые должны быть освобождены после их использования. В результате, некоторым классам требуется функция, которая будет гарантированно вызвана при уничтожении объекта, аналогично конструктору, который гарантированно вызывается при создании объекта. Такие функции называются <i>деструкторами</i>. Они, как правило, очищают память и освобождают ресурсы. Деструкторы вызываются неявно, когда автоматическая переменная выходит из области видимости, удаляется объект, хранящийся в свободной памяти и т. д. Только в очень необычных ситуациях требуется явно вызывать деструктор.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Наиболее часто деструктор используется для освобождения памяти, выделенной конструктором. Рассмотрим простую таблицу элементов типа <i>Name</i>. Конструктор класса <i>Table</i> должен выделить память для хранения элементов. После того как таблица уничтожена каким-либо способом, нужно быть уверенным, что эта память будет освобождена для дальнейшего использования. Добиться этого можно, реализовав деструктор:</p>
	
	
<pre>
<div class="code">

class Name
{
  const char * s;
  // ...
};
class Table
{
  Name * p;
  size_t sz;
public:
  // конструктор
  Table(size_t s = 15) { p = new Name[sz = s]; }
  // деструктор
  ~Table() { delete[] p; }
  // ...
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Таким образом, деструктор &ndash; это функция-элемент класса, имя  которой совпадает с именем класса, но дополнено справа символом '~' (символ '~' не является допустимым для создания идентификатора объекта другого назначения).  Деструктор не может быть переопределен, не должен иметь аргументы и возвращать результат.</p>
		
<div class="title"><a name="2_3">2.3.Конструкторы по умолчанию</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
В предыдущем примере конструктор <i>Date()</i> является конструктором по умолчанию, который и будет задействован при инициализации, если пользователь не объявил другие конструкторы. В противном случае компилятор попытается сгенерировать конструктор по умолчанию. Конструктор по умолчанию, сгенерированный компилятором, неявно вызывает конструкторы по умолчанию для элементов класса и конструкторы базовых классов. Например:</p>
	
	
<pre>
<div class="code">
class Dates
{
  Date sd;
  Date vd[10];
};

Dates dd;
</div>
</pre>
	
		
В этом примере переменная dd будет проинициализирована сгенерированным конструктором по умолчанию, который вызовет <i>Date()</i> для <i>dd.sd</i> и каждого элемента <i>dd.vd</i>.
		<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Так как константы и ссылки должны быть проинициализированы, класс, содержащий элементы, являющиеся константами или ссылками, не может быть сконструирован по умолчанию, если только не был предоставлен явно конструктор по умолчанию. Например:</p>
	
	
<pre>
<div class="code">
class X
{
  const int a;
  const int&amp; r;
}

X x; // ошибка: нет конструктора по умолчанию для X
</div>
</pre>
	
		
Встроенные типы также имеют конструкторы по умолчанию.
		<div class="title"><a name="2_4">2.4.Конструкторы вложенных классов</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Объект любого класса может быть элементом другого класса. В таких случаях иногда возникает необходимость задания конструктором включающего класса параметров конструкторов элементов включаемых классов.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Схема описания связи параметров конструкторов:</p>
	
	
<pre>
<div class="code">
class X
{  // описание включаемого класса
  int a;
public:
  X(int i) { a = i; } // конструктор с параметром
};

class Y
{  // описание включающего класса
  // ...
  // описание элементов включаемых классов
  X elem_1; // параметры здесь указать нельзя,
  X elem_2; // так как это только описание класса, а
  // ...    // параметры относятся к определяемым
            // обьектам
public:
  // определение конструктора включающего класса
  Y(int i1, int i2):elem_1(i1), elem_2(i2)
  {
    // ...
  }
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
В определении конструктора включающего класса после символа &laquo;:&raquo; записывается  в произвольном порядке список элементов включаемых классов с указанием в круглых скобках параметров их конструкторов. Конструкторы включаемых элементов будут вызваны перед конструктором включающего класса. Порядок вызова конструкторов элементов не определен, поэтому список параметров не должен содержать взаимосвязанные выражения присваивания.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
В качестве представителей вложенных классов могут рассматриваться элементы базовых типов, поэтому определение конструктора в классе</p>
	
	
<pre>
<div class="code">
class Alpha
{
  int i;
  clock_t s;
public:
  Alpha():i(0), s(clock())
  {
    printf("\n i = %d, s = %d", i, s);
  }
};
</div>
</pre>
	
		
эквивалентно следующему варианту с операторами присваивания
	
	<pre>
<div class="code">
Alpha()
{
  i = 0;
  s = clock();
  printf("\n i = %d, s=%d", i, s);
}
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Этим обстоятельством можно воспользоваться для повышения лаконичности исходного текста программы.</p>
		
<div class="title"><a name="2_5">2.5.	Конструирование массивов объектов</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Если объект класса может быть создан конструктором по умолчанию, то можно определить массив элементов этого класса. Например:</p>
	
	
<pre>
<div class="code">
Table tbl[10];
</div>
</pre>
	
		
В результате будет создан массив из десяти объектов типа <i>Table</i>, и каждый элемент будет проинициализирован при помощи вызова конструктора <i>Table::Table()</i> с аргументом по умолчанию равным 15.
		<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Не существует способа явного указания аргументов конструктора при объявлении массива. Если необходимо проинициализировать элементы массива различными значениями, можно написать конструктор по умолчанию, который непосредственно или косвенно считывает и записывает нелокальные данные. Например:</p>
	
	
<pre>
<div class="code">
class Ibuffer
{
  string buf;
public:
  Ibuffer() { cin &gt;&gt; buf; }
  // ...
};

void f()
{
  Ibuffer words[100]; // каждое слово
                      // инициализируется из cin
}
</div>
</pre>
	
		Как правило, лучше избегать подобных сложностей.
		<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Деструктор для каждого созданного элемента массива вызывается при уничтожении массива. Это происходит неявно для массивов, память под которые не выделялась оператором <i>new</i>. Компилятор не различает указатель на отдельный объект от указателя на первый элемент массива. Поэтому необходимо указывать удаляется массив или отдельный объект. Например:</p>
	
	
<pre>
<div class="code">
void f(int sz)
{
  Table * t1 = new Table;
  Table * t2 = new Table[sz];
  Table * t3 = new Table;
  Table * t4 = new Table[sz];
  // ...
  delete t1;   // правильно
  delete[] t2; // правильно
  delete[] t3; // неправильно
  delete t4;   // неправильно
}

	</div>
</pre>
	
		
<div class="title"><a name="2_6">2.6.Конструирование статических объектов</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Конструкторы глобальных статических объектов вызываются в порядке их определений до выполнения программы. Рассмотрим пример:</p>
	
	
<pre>
<div class="code">
class X {
  // ...
  static Table memtbl;
};
Table tbl;

Table X::memtbl;

namespace Z
{
  Table tbl2;
}
</div>
</pre>
	
		
Порядок создания следующий: <i>tbl</i>, затем <i>X::memtbl</i> и затем <i>Z::tbl2</i>. Причем объявление (в отличие от определения), наподобие объявления memtbl в <i>X</i>, не влияет на порядок создания. Деструкторы вызываются в порядке, обратном вызову конструкторов.
		<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Конструктор локального статического объекта вызывается один раз при первом выполнении инструкции, содержащей определение объекта. Рассмотрим пример:</p>
	
	
<pre>
<div class="code">
void f(int i)
{
  static Table tbl1;
  // ...
  if (i)
  {
    static Table tbl2;
    // ...
  }
}

void main()
{
  f(0);
  f(1);
  f(2);
}
</div>
</pre>
	
		В этом примере конструктор <i>tbl1</i> вызывается только при первом вызове <i>f()</i>. Так как переменная <i>tbl1</i> объявлена статической, она не уничтожается по возвращению из <i>f()</i> и не создается повторно при следующем вызове <i>f()</i>. В виду того, что блок, содержащий объявление <i>tbl2</i>, не выполняется при вызове <i>f(0)</i>, <i>tbl2</i> не создается до вызова <i>f(1)</i>. И эта переменная не конструируется снова при втором входе в блок.
		<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Деструкторы локальных статических объектов вызываются в порядке, обратном созданию, при завершении программы. В какой момент точно &ndash; не определено.</p>
		
<div class="title"><a name="2_7">2.7.Копирование объектов</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
По умолчанию, объекты класса можно копировать. В частности, объект некоторого класса можно проинициализировать при помощи копирования объекта того же класса. Например:</p>
	
	
<pre>
<div class="code">
class X { /* ... */ };

X x1;
X x2 = x1;
</div>
</pre>
	
		
По умолчанию, копия объекта класса содержит копию каждого элемента. Если это не совсем то, что нам требуется для класса X, можно реализовать более подходящее поведение, определив, конструктор копирования <i>X::X(const X&amp;)</i>.
		<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Рассмотрим конкретный пример.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Если <i>t1</i> и <i>t2</i> являются объектами класса Table, выражение <i>t2 = t1</i> по умолчанию означает почленное копирование <i>t1</i> в <i>t2</i>. При наличии у объектов элементов, являющихся указателями, такая интерпретация присваивания может вызвать неожиданный (и обычно нежелательный) эффект. Почленное копирование обычно является неправильным при копировании объектов, имеющих ресурсы, управляемые парой конструктор/деструктор. Например:</p>
	
	
<pre>
<div class="code">
void h()
{
  Table t1;
  Table t2 = t1; // копирующая инициализация &ndash; проблема
}
</div>
</pre>
	
		
В этом примере конструктор <i>Table</i> по умолчанию будет вызван один раз для <i>t1</i>. Он не вызовется для <i>t2</i>, потому что эта переменная проинициализирована при помощи копирования. Однако деструктор <i>Table</i> вызывался два раза: по одному разу для <i>t1</i> и  <i>t2</i>! По умолчанию копирование интерпретируется как почленное копирование, поэтому <i>t1</i> и <i>t2</i> к концу <i>h()</i> будут содержать указатели на массив имен, выделенный в свободной памяти при создании <i>t1</i>. С другой стороны, массив, созданный для <i>t1</i>, будет и в <i>t2</i>, поэтому он будет дважды удаляться. Результат непредсказуем и вероятно, приведет к катастрофе.
		<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Можно избежать подобных аномалий, определив, что понимать под копированием <i>Table</i>:</p>
	
	
<pre>
<div class="code">
class Table
{
  // ...
public:
  Table(const Table&amp;); // копирующий конструктор
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Можно определить любой подходящий смысл конструктора копирования, но традиционным решением является поэлементное копирование хранимых элементов. Например:</p>
	
	
<pre>
<div class="code">
Table::Table(const Table&amp; t)
{
  p = new Name[sz = t.sz];
  for(int i = 0; i&lt; sz; i++) p[i] = t.p[i];
}
</div>
</pre>
	
		
<br>
<br>
<div class="title">
<a name="3"></a>3.	ИНДИВИДУАЛЬНЫЕ ЗАДАНИЯ</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Для всех вариантов заданий:</p>
		
<ul>
			
<li>определить классы их свойства и методы в соответствии с вариантом задания;</li>
			
<li>в функции <b>main()</b> реализовать демонстрацию работы с объектами созданных классов;</li>
		
</ul>
		
<br>
<br>
<div class="header">
<a name="|||||"></a>ЗАМЕЧАНИЯ:</div>
		
<ul>
			
<li>Весь ввод/вывод должен осуществляться только внутри функции <b>main()</b>.</li>
			
<li>Передача в функции объектов типа класс должна осуществляться через указатель либо ссылку на объект.</li>
			
<li>Все другие нестатические данные должны передаваться функциям через параметры.</li>
			
<li>Все нестатические элементы класса должны иметь закрытый атрибут доступа. Доступ извне к таким элементам должен осуществляться через функции-элементы класса.
</li>
		
</ul>
		
<br>
<br>
<div class="header">
<a name="|||||"></a>Варианты заданий</div>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>1)</b>	Определите класс <b>Date</b> для хранения даты:</p>
	
	
<pre>
<div class="code">
class Date
{
	unsigned y;	//год
	unsigned m;	//месяц
	unsigned d;	//день
	...
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите элементы-функции, которые читают дату из потока ввода, выводят дату. Определите функцию (с параметрами по умолчанию), которая добавляет день, месяц или год к дате. Определите дружественную функцию, которая вычисляет разницу в днях между двумя датами.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Определить в классе конструкторы: по умолчанию, с параметрами, копирования</b>.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>2)</b>	Определите класс <b>Time</b> для хранения времени:</p>
	
	
<pre>
<div class="code">
class Time
{
	unsigned h;	//часы
	unsigned m;	//минуты
	unsigned s;	//секунды
	...
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите элементы-функции, которые читают время из потока ввода, выводят время. Определите функцию (с параметрами по умолчанию), которая добавляет часы, минуты или секунды ко времени. Определите дружественную функцию, которая возвращает количество секунд прошедших от time1 до time2.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определить в классе конструкторы: по умолчанию, с параметрами, копирования.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>3)</b>	Определить класс <b>TextFile</b> для представления текстовых файлов</p>
	
	
<pre>
<div class="code">
class TextFile
{
	char name[256];	//имя файла
	int length;		//размер файла
	char * buff;		//буфер для текста
	...
};
</div>
</pre>

	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите в классе следующие функции:</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Open()</b> &ndash; открытие файла. Функция должна создать буфер и прочитать в него содержимое файла;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>AddText()</b> &ndash; добавление текста в конец файла;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>PasteText()</b> &ndash; вставка текста в произвольное место;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Save()</b> &ndash; сохранение файла. Функция должна иметь параметр &ndash; имя файла со значением по умолчанию NULL. Если используется значение по умолчанию, то файл сохраняется с именем, которое было указано при его открытии;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Print()</b> &ndash; вывод содержимого файла на экран.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Определить в классе конструкторы: по умолчанию, с параметрами, копирования. Определить деструктор.</b>
		
</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>4)</b>	Определите узел бинарного дерева следующим образом:</p>
	
	
<pre>
<div class="code">
class Node
{
	char name[10];	//имя узла
	Node * left;		//левая ветвь
	Node * right;	//правая ветвь
	...
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Определите в классе следующие функции:</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Init()</b> &ndash; инициализация узла. Функция должна установить указатели на левый и правый узел в ноль;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>AddNode()</b> &ndash; добавление узла в левую или правую ветви. Если слева нет узла, то добавить слева, если справа нет узла, то добавить справа, иначе ничего не добавлять;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>DelTree()</b> &ndash; удаление поддеревьев;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Print()</b> &ndash; рекурсивная функция вывода дерева на экран.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Определить в классе конструкторы: по умолчанию, с параметрами, копирования. Определить деструктор.</b>
		
</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>5)</b>	Определите элемент односвязного списка и список:</p>
	
	
<pre>
<div class="code">
struct ListItem
{
	char * data;	//указатель на данные
	List * next;	//указатель на следующий элемент
};
class List
{
	ListItem * list;
	...
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите в классе <b>List</b> следующие функции:</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Init()</b> &ndash; инициализация списка. Установка <b>list</b> в ноль;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Add()</b> &ndash; добавление нового элемента в начало или конец списка (предусмотреть обе возможности);</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Add()</b> &ndash; перегруженная функция добавления нового элемента в позицию с индексом i;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Print()</b> &ndash; вывод содержимого списка на экран;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Delete()</b> &ndash; удаление i-го элемента из списка.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Определить в классе конструкторы: по умолчанию, с параметрами, копирования. Определить деструктор.</b>
		
</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>
6)</b>	Имеется элемент стека (дисциплина обслуживания LIFO) и стек:</p>
	
	
<pre>
<div class="code">
struct StackItem
{
	char * data;	//указатель на данные
	Stack * prev;	//указатель на предыдущий элемент
};
class Stack
{
	StackItem * stack;
	...
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите в классе <b>Stack</b> следующие функции:</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Init()</b> &ndash; инициализация стека. Установка <b>stack</b> в ноль;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Push()</b> &ndash; поместить данные в стек;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Pop()</b> &ndash; извлечь данные из стека (при этом элемент удаляется из стека);</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Print()</b> &ndash; дружественная функция вывода на экран содержимого стека.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Определить в классе конструкторы: по умолчанию, с параметрами, копирования. Определить деструктор.</b>
		
</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>7)</b>	Определите класс <b>String</b> для хранения строки символов:</p>
	
	
<pre>
<div class="code">
class String
{
	char * str;	//строка
	int length;	//длина строки
	...
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите в классе следующие функции:</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Init()</b> &ndash; инициализация некоторой строкой;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Concat()</b> &ndash; добавление в конец строки другой строки;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Length()</b> &ndash; определение длины строки;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Char()</b> &ndash; функция, возвращающая символ с индексом i;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Print()</b> &ndash; дружественная функция вывода строки на экран.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Определить в классе конструкторы: по умолчанию, с параметрами, копирования. Определить деструктор.</b>
		
</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>8)</b>	Имеется элемент очереди и очередь (дисциплина обслуживания FIFO):</p>
	
	
<pre>
<div class="code">
struct QueueItem
{
	char * data;		//указатель на данные
	QueueItem * next;	//указатель на следующий элемент очереди
}
class Queue
{
	QueueItem * queue;
	...
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите в классе <b>Queue</b> следующие функции:</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Init()</b> &ndash; инициализация очереди. Установка queue в ноль;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Put()</b> &ndash; поместить элемент в конец очереди;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Get()</b> &ndash; извлечь элемент из очереди (при этом элемент удаляется из очереди);</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Print()</b> &ndash; статическая функция вывода на экран содержимого очереди.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Определить в классе конструкторы: по умолчанию, с параметрами, копирования. Определить деструктор.</b>
		
</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>9)</b>	Определите класс <b>Complex</b>:</p>
	
	
<pre>
<div class="code">
class Complex
{
	double re;	//вещественная часть
	double im;	//мнимая часть
	...
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Определите в классе следующие функции:</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Init() </b>&ndash; инициализация числа (установка значений действительной и мнимой части);</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Add()</b>, <b>Sub()</b>, <b>Mul()</b>, <b>Div()</b> &ndash; операции &laquo;+&raquo;, &laquo;&ndash;&raquo;, &laquo;*&raquo; и &laquo;/&raquo; над комплексными числами. Все функции должны возвращать ссылку на новое комплексное число, содержащее результат операции;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Print()</b> &ndash; статическая функция вывода значения комплексного числа на экран в алгебраической или показательной формах.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Определить в классе конструкторы: по умолчанию, с параметрами, копирования.</b>
		
</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>10)</b>	Определите класс <b>TreeNode</b> &ndash; узел:</p>
	
	
<pre>
<div class="code">
class TreeNode
{
	char name[10];		//имя узла
	TreeNode * nodes;	//список дочерних узлов
	TreeNode * next;	//следующий узел на том же уровне
	...
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите в классе следующие функции:</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Init()</b> &ndash; инициализация узла. Установка nodes и next в ноль;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>AddNode()</b> &ndash; добавление нового узла на том же уровне;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>AddChildNode()</b> &ndash; добавление нового дочернего узла;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>DelTree()</b> &ndash; статическая функция удаление всего дерева или его части;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Print()</b> &ndash; дружественная функция вывода дерева (имен узлов) на экран.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Определить в классе конструкторы: по умолчанию, с параметрами, копирования. Определить деструктор.</b>
		
</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>11)</b>	Определите структуру <b>Pair</b> &ndash; пара &laquo;имя = значение&raquo; и класс Pairs &ndash; массив пар:</p>
	
	
<pre>
<div class="code">
struct Pair
{
	char name[21];	//имя
	int value;		//значение
};
class Pairs
{
	Pair * prs;	//массив пар
	int length;	//размер массива
	int count;	//количество имеющихся пар в массиве
	...
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Определите в классе <b>Pairs</b> следующие функции:</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Init()</b> &ndash; инициализация массива пар (функция получает начальный размер массива и создает массив);</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>GetValue()</b> &ndash; получить значение для заданного имени (функция должна возвратить 0 если нет такого имени и 1 в случае успеха, а значение возвращается через параметр функции, передаваемый по ссылке или указателю);</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>SetValue()</b> &ndash; установить значение для заданного имени (если такого имени в массиве нет, то добавить в массив новую пару);</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Print()</b> &ndash; дружественная функция вывода всех пар на экран.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Определить в классе конструкторы: по умолчанию, с параметрами, копирования. Определить деструктор.</b>
		
</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>
12)</b>	Определите класс <b>Array</b> &ndash; одномерный массив вещественных чисел:</p>
	
	
<pre>
<div class="code">
class Array
{
	double * arr;	//непосредственно массив
	unsigned size;	//размер массива
	...
};
</div>
</pre>
	
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
Определите в классе следующие функции:</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Init()</b> &ndash; создание нового массива, размер которого передается в качестве параметра;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>DelArray()</b> &ndash; освобождение памяти занятой массивом;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Set()</b> &ndash; установить новое значение i-го элемента массива;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Get()</b> &ndash; получить значение i-го элемента массива;</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Print()</b> &ndash; дружественная функция вывода элементов массива на экран.</p>
		
<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			
			<b>Определить в классе конструкторы: по умолчанию, с параметрами, копирования. Определить деструктор.</b>
		
</p>
				
<center>[<a href="lab2.html">Предыдущая работа</a>][<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="lab4.html">Следующая работа</a>]</center>

	

</body>
</html>
