<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Лабораторная работа №7</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head>
<body>


<div class="title">ЛАБОРАТОРНАЯ РАБОТА № 7</div>


<div class="title">ОБРАБОТКА ИСКЛЮЧЕНИЙ</div>

<center>[<a href="lab6.html">Предыдущая работа</a>][<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="lab8.html">Следующая работа</a>]</center>

<br>
<br>
<div class="title">
<a name="0"></a>Оглавление</div>

<ol type="1">

<li>
<a href="#1">Цель работы</a>
</li>

<li>
<a href="#2">Обработка исключительных ситуаций</a>
</li>

<ul>

<li>
<a href="#2_1">Схема обработки исключений в С++</a>
</li>

<li>
<a href="#2_2">Иерархическое управление исключениями</a>
</li>

<li>
<a href="#2_3">Обработка исключений  в конструкторах и деструкторах</a>
</li>

<li>
<a href="#2_4">Структурное управление исключениями</a>
</li>

<li>
<a href="#2_5">Кадрированное управление исключениями</a>
</li>

<li>
<a href="#2_6">Завершающее управление исключениями</a>
</li>

</ul>

<li>
<a href="#3">Индивидуальные задания</a>
</li>

</ol>


<br>
<br>
<div class="title">
<a name="1"></a>1.	ЦЕЛЬ РАБОТЫ</div>

<ol type="1">

<li> Изучение способов обнаружения ошибок времени выполнения с помощью исключений.</li>

<li>Изучение основных принципов обработки исключений в языке С++.</li>

<li>Знакомство со структурным управлением исключениями.</li>

</ol>


<br>
<br>
<div class="title">
<a name="2"></a>2.	ОБРАБОТКА ИСКЛЮЧИТЕЛЬНЫХ СИТУАЦИЙ</div>


<br>
<br>
<div class="header">
<a name="2_1"></a>2.1.	Схема обработки исключений в С++</div>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			 Понятие <i>исключения</i> (<i>exception</i>) введено для генерации в системе сообщения об ошибке. Например:</p>


<pre>
<div class="code">
struct Range_error
{
  int i;
  Range_error(int ii):i(ii) { }
};

char to_char(int i)
{
  if(i &lt; numeric_limits&lt;char&gt;::min() ||
     i &gt; numeric_limits&lt;char&gt;::max()) throw Range_error(i);
  return i;
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Функция <i>to_char()</i> либо возвращает <i>char</i> по числовому значению <i>i</i>, либо генерирует исключение <i>Range_error</i>. Основная идея состоит в том, функция, обнаружившая проблему, которую она не знает как решать, генерирует (<i>throw</i>) исключение в надежде, что вызывающий (прямо или косвенно) модуль знает, что делать в этой ситуации. Функция, которая собирается обрабатывать ошибку, может объявить, что она будет <i>перехватывать</i> (<i>catch</i>) исключения данного типа. Например, для вызова <i>to_char()</i> и перехвата исключений, которые она может вызвать, можно написать:</p>
 

<pre>
<div class="code">
void f(int i)
{
  try
  {
    char c = to_char(i);
    // ...
  }
  catch(Range_error)
  {
    cerr &lt;&lt; &ldquo;\n проблема!&rdquo;;
  }
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Конструкция</p>


<pre>
<div class="code">
catch(/*...*/) { /* ... */ }
</div>
</pre>

называется <i>обработчиком исключений</i>. Она может использоваться только сразу после блока, начинающегося с ключевого слова <i>try</i>, или сразу после другого обработчика; <i>catch</i> также является ключевым словом. В скобках находится объявление, которое используется аналогично объявлению аргументов функции. То есть, оно указывает тип объектов, которые могут быть перехвачены этим обработчиком, и (необязательно) присваивает имена перехватываемым объектам. Например:

<pre>
<div class="code">
void g(int i)
{
  try
  {
    char c = to_char(i);
    // ...
  }
  catch(Range_error x)
  {
    cerr &lt;&lt; &ldquo;\n проблема!: to_char(&rdquo; &lt;&lt; x.i &lt;&lt; &ldquo;)\n&rdquo;;
  }
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Если код в <i>try</i>-блоке, или код, вызываемый из него, генерирует исключение, будут проверяться обработчики этого блока <i>try</i>. Если сгенерированное исключение имеет тип, указанный в одном из обработчиков, будет выполнен этот обработчик. В противном случае обработчики игнорируются и <i>try</i>-блок ведет себя как обыкновенный блок. Если исключение сгенерировано и ни один из <i>try</i>-блоков не перехватил его, выполнение программы прекращается.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Обработка исключений в С++ в основном является методом передачи управления специальному коду в вызывающем модуле. </p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Как правило, в программе существует несколько возможных типов ошибок на этапе выполнения. Такие ошибки можно распределить между исключениями с различными именами. Предпочтительней определять типы исключений (это сводит к минимуму некоторые неоднозначности, связанные с их назначением) и не использовать встроенные типы.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Предположим, что имеется программа калькулятор, который должен обрабатывать две ошибки времени выполнения: синтаксические ошибки и попытку деления на ноль. Нет необходимости передавать какое-либо значение обработчику из кода, обнаружившего попытку деления на ноль, поэтому деления на ноль может быть представлено простым пустым типом:</p>


<pre>
<div class="code">
class Zero_divide { };
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			С другой стороны, обработчик скорее всего предпочел бы получать информацию о том, какого вида встретилась синтаксическая ошибка. Например:</p>


<pre>
<div class="code">
class Syntax_error
{
public:
  const char* p;
  Syntax_error(const char* q) { p = q; }
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Теперь можно разделить обработку этих двух исключений, добавив обработчики после блока <i>try</i>. При генерации исключения выполнится соответствующий обработчик. По завершении обработки исключения управление передается за конец списка обработчиков:</p>


<pre>
<div class="code">
try
{
  // ...
}
catch(Syntax_error se)
{
  // обработка синтаксической ошибки
  cerr &lt;&lt; &ldquo;\nСинтаксическая ошибка: &rdquo; &lt;&lt; se.p;
  // ...
}
catch()
{
  // обработка деления на ноль
  cerr &lt;&lt; &ldquo;\nДеление на ноль&rdquo;;
}
catch(...)
{
  // обработка остальных ошибок
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Также как и в функциях, многоточие <i>&laquo;...&raquo;</i> означает <i>&laquo;любой аргумент&raquo;</i>, поэтому <i>catch(...)</i> означает <i>&laquo;перехват всех исключений&raquo;</i>. Такой неспециализированный блок <i>catch()</i> обозначает способность обрабатывать не обслуженные предшествующими блоками исключения, поэтому он должен размещаться последним.</p>



<br>
<br>
<div class="header">
<a name="2_2"></a>2.2.	Иерархическое управление исключениями</div>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Исключение является объектом некоторого класса, являющегося представлением исключительного случая. Код, обнаруживший ошибку, генерирует объект инструкцией <i>throw</i>. Фрагмент кода выражает свое желание обрабатывать исключение при помощи инструкции <i>catch</i>. Результатом <i>throw</i> является поиск подходящего <i>catch</i> (в функции, которая непосредственно или косвенно вызывала функцию, сгенерировавшую исключение).</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Часто исключения естественным образом разбиваются на семейства. Из этого следует, что наследование может оказаться полезным для структурирования исключений и помочь при их обработке. Например, исключения для математической библиотеки можно организовать следующим образом:</p>


<pre>
<div class="code">
class Math_err { };
class Overflow : public Math_err { };  // переполнение сверху
class Underflow : public Math_err { }; // переполнение снизу
class Zerodivide : public Math_err { };// деление на ноль
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Это позволяет обрабатывать любой <i>Math_err</i>, не заботясь о том, какое в точности исключение возникло. Например:</p>


<pre>
<div class="code">
void f()
{
  try { /* ... */ }
  catch(Overflow)
  {
    // обработка Overflow или всех производных от Overflow
  }
  catch(Math_err)
  {
    // обработка любой Math_err, не являющейся Overflow
  }
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Использование иерархий классов для обработки исключений естественным образом приводит к обработчикам, интересующимся лишь подмножеством информации, которую несут с собой исключения. Другими словами, исключение обычно перехватывается обработчиком его базового класса, а не обработчиком его собственного класса. Семантика перехвата и задания имен исключений идентична семантике функции с аргументом. Из этого следует, что сгенерированное исключение &laquo;срезается&raquo; до перехваченного. Например:</p>


<pre>
<div class="code">
class Math_err
{
  // ...
  virtual void debug_print() const
  { cerr &lt;&lt; &ldquo;\nМатематическая ошибка&rdquo;; }
};

class Int_overflow : public Math_err
{
  const char* op;
  int a1, a2;
public:
  Int_overflow(const char* p, int a, int b)
  { op = p; a1 = a; a2 = b; }
  virtual void debug_print() const
  { cerr &lt;&lt; &lsquo;\n&rsquo; &lt;&lt; op &lt;&lt; &lsquo;(&rsquo; &lt;&lt; a1 &lt;&lt; &lsquo;,&rsquo; &lt;&lt; a2 &lt;&lt; &lsquo;)&rsquo;; }
  // ...
};

void f()
{
  try
  {
    g();
  }
  catch(Math_err m)
  {
    // ...
  }
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Когда вызывается обработчик <i>Math_err</i>, <i>m</i> является объектом <i>Math_err</i> &ndash; даже если вызов <i>g()</i> привел к генерации <i>Int_overflow</i>. Это означает, что дополнительная информация, имеющаяся в <i>Int_overflow</i>, недоступна.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Во избежание потери информации можно использовать указатели или ссылки. Например:</p>


<pre>
<div class="code">
int add(int x, int y)
{
  if((x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; x &gt; INT_MAX - y)||
     ( x &lt; 0 &amp;&amp; y &lt; 0 &amp;&amp; x &lt; INT_MIN - y))
     throw Int_overflow(&ldquo;+&rdquo;, x, y);
  return x + y;
}

void f()
{
  try
  {
    int i1 = add(1, 2);
    int i2 = add(INT_MAX, -2);
    int i3 = add(INT_MAX, 2); // Приехали!
  }
  catch(Mathe_rr&amp; m)
  {
    // ...
    m.debug_print();
  }
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Последний вызов <i>add()</i> приведет к исключению, которое вызовет <i>Int_overflow::debug_print()</i>. Если бы исключение перехватывалось по значению, а не по ссылке, была бы вызвана функция <i>Math_err::debug_print()</i>.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Не каждая группа исключений является древообразной структурой. Довольно часто исключение принадлежит сразу двум группам. Например:</p>


<pre>
<div class="code">
//  ошибка, связанная с файлом в сети
class NetFile_err : public NetWork_err, public FileSystem_err
{
  // ...
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<i>NetFile_err</i> может перехватываться функциями, работающими с исключениями в сети:</p>


<pre>
<div class="code">
void f()
{
  try { /* ... */ }
  catch(NetWork_err&amp; nwe) { /* ... */ }
}
</div>
</pre>

а также функциями, работающими с исключениями файловой системы:

<pre>
<div class="code">
void g()
{
  try { /* ... */ }
  catch(FileSystem_err&amp; fse) { /* ... */ }
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Такая иерархическая организация обработки ошибок имеет большое значение в тех случаях, когда службы (например, сетевые) прозрачны для пользователя. В этом примере автор <i>g()</i> мог и не подозревать о существовании сети.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Рассмотрим пример:</p>


<pre>
<div class="code">
void f()
{
  try
  {
    throw E();
  }
  catch(H) { /* ... */ }
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Обработчик будет вызван:</p>

<ol type="1">

<li>если <i>Н</i> того же типа, что и <i>Е</i>;</li>

<li>если <i>Н</i> является открытым базовым классом <i>Е</i>;</li>

<li>если <i>Н</i> и <i>Е</i> являются указателями, и 1 или 2 выполняется для типов, на которые они ссылаются;</li>

<li>если <i>Н</i> и <i>Е</i> являются ссылками, и 1 или 2 выполняется для типа, на который Н ссылается.</li>

</ol>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Кроме того, можно добавить модификатор <i>const</i> к типу, используемому для перехвата исключения. Это воспрепятствует модификации перехваченного исключения.</p>



<br>
<br>
<div class="header">
<a name="2_3"></a>2.3.	Обработка исключений  в конструкторах и деструкторах</div>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Исключения предоставляют способ решить следующую проблему: как сообщить об ошибке из конструктора. В виду того, что конструктор не возвращает отдельного значения, которое вызывающая функция могла бы проверить, традиционными (то есть без обработки исключений) альтернативами остаются:</p>

<ul>

<li>возвратить объект в &laquo;неправильном&raquo; состоянии и полагаться на то, что пользователь проверит его состояние;</li>

<li>присвоить значение нелокальной переменной (например, <i>errno</i>) для указания на неуспешное создание объекта и полагаться на то, что пользователь проверит значение переменной;</li>

<li>не осуществлять никакой инициализации в конструкторе и полагаться на то, что пользователь вызовет функцию инициализации до первого использования;</li>

<li>пометить объект как неинициализированный и при первом вызове функции-элемента для этого объекта осуществить инициализацию (такая функция &ndash; не конструктор &ndash; может вернуть сообщение об ошибке в случае неуспешной инициализации).</li>

</ul>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Обработка исключений позволяет передать информацию неуспешной инициализации из конструктора. Например, простой класс <i>Vector</i> мог бы защититься от запроса слишком большого количества памяти следующим образом:</p>


<pre>
<div class="code">
class Vector
{
public:
  class Size_err { };
  enum { max = 32000 };
  Vector(int sz)
  {
    if(sz &lt; 0 || sz &gt; max) throw Size();
    // ...
  }
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Код, создающий вектора, теперь может перехватывать ошибки <i>Vector::Size_err</i>, которые можно каким-либо образом обработать:</p>


<pre>
<div class="code">
Vector* f(int s)
{
  try
  {
    Vector* p = new Vector(s)
    // ...
    return p;
  }
  catch(Vector::Size_err)
  {
    // обработка ошибки размера вектора
  }
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Когда код, инициализирующий элемент (непосредственно или косвенно), генерирует исключение, оно (по умолчанию) передается туда, где вызван конструктор для класса этого элемента. Однако сам конструктор может перехватывать такие исключения, помещая все тело функции, включая список инициализаторов элементов, в блок <i>try</i>. Например:</p>


<pre>
<div class="code">
class X
{
  Vector v;
  // ...
public:
  X(int);
  // ...
};

X::X(int s)

try : v(s)              // инициализация v при помощи s
{
  // ...
}
catch(Vector::Size_err) // перехват исключений
{                       // сгенерированных при 
  // ...                // инициализации v
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			С точки зрения обработки исключений деструктор может вызываться одним из двух способов:</p>

<ul>

<li>
<i>нормальный вызов</i>: в результате нормального выхода имени из области видимости, использования оператора <i>delete</i> и т. д.;</li>

<li>
<i>вызов в процессе обработки исключения</i>: в процессе раскручивания стека механизм обработки исключения приводит к выходу из области видимости, содержащей объект с деструктором.</li>

</ul>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Во втором случае исключение не должно покинуть сам деструктор. Если все-таки покинет, это считается ошибкой механизма обработки исключений и вызывается <i>std::terminate()</i>. Все же не существует общего способа определить, в праве ли механизм обработки исключений или деструктор проигнорировать одно исключение ради обработки другого.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Деструктор в состоянии защитить себя, если он вызывает функции, которые могут сгенерировать исключения. Например:</p>


<pre>
<div class="code">
X::~X() try
{
  f(); // может сгенерировать исключение
}
catch(...)
{
  // некоторые действия
}
</div>
</pre>


<br>
<br>
<div class="header">
<a name="2_4"></a>2.4.	Структурное управление исключениями</div>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			В современных системах программирования на языках C/C++ существует механизм так называемого структурного управления исключениями, где исключения идентифицируются только типом <i>unsigned int</i>. Структурное управление исключениями позволяет наряду с обработкой потока явно порождаемых программой исключений обрабатывать и исключения, порождаемые операционной системой в аварийных ситуациях. Этим объясняется наличие единственного типа идентификации исключений и, как следствие, единственного блока обработки исключений в контролируемом блоке программы.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Различают две разновидности структурного управления исключениями:</p>

<ul>

<li>
<i>кадрированное управление</i> &ndash; блок обработки исключений активизируется только в момент порождения исключения;</li>

<li>
<i>завершающее управление</i> &ndash; любой вид выхода из контролируемого блока программы завершается активизацией предопределенного блока операторов.</li>

</ul>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Операторы контролируемого блока могут явно породить исключение, используя функцию</p>


<pre>
<div class="code">
VOID RaiseException (
  DWORD dwExceptionCode,
  DWORD dwExceptionFlags,
  DWORD nNumberOfArguments,
  CONST DWORD *lpArguments );
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Интерпретация параметров функции <i>RaiseException</i>:</p>

<ul>

<li>
<i>dwExceptionCode</i> &ndash; код исключения;</li>

<li>
<i>dwExceptionFlags</i> &ndash; флаг возобновления исключения;</li>

<li>
<i></i>nNumberOfArguments &ndash; количество аргументов детализации описания исключения в массиве <i>lpArguments</i>.</li>

</ul>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Предопределенные коды исключений:</p>

<ul>

<li>
<i>EXCEPTION_ACCESS_VIOLATION</i> &ndash; чтение или запись по адресу, не имея на то соответствующих прав;</li>

<li>
<i>EXCEPTION_DATATYPE_MISALIGNMENT</i> &ndash; попытка чтения или записи данных с нарушением выравнивания;</li>

<li>
<i>EXCEPTION_BREAKPOINT</i> &ndash; достигнута точка прерывания;</li>

<li>
<i>EXCEPTION_SINGLE_STEP</i> &ndash; сигнал о том, что одиночная команда была выполнена;</li>

<li>
<i>EXCEPTION_ARRAY_BOUNDS_EXCEEDED</i> &ndash; выход за пределы массива;</li>

<li>
<i>EXCEPTION_FLT_DENORMAL_OPERAND</i> &ndash; недопустимое значение операнда в операциях с плавающей точкой;</li>

<li>
<i>EXCEPTION_FLT_DIVIDE_BY_ZERO</i> &ndash; попытка деления на ноль в операциях с плавающей точкой;</li>

<li>
<i>EXCEPTION_FLT_INEXACT_RESULT</i> &ndash; результат операции с плавающей точкой не может быть представлен в виде десятичной дроби;</li>

<li>
<i>EXCEPTION_FLT_INVALID_OPERATION</i> &ndash; любое другое исключение в операциях с плавающей точкой, не включенное в этот список;</li>

<li>
<i>EXCEPTION_FLT_OVERFLOW</i> &ndash; операция с плавающей запятой вызвала переполнение;</li>

<li>
<i>EXCEPTION_FLT_STACK_CHECK</i> &ndash; переполнение стека в операциях с плавающей точкой;</li>

<li>
<i>EXCEPTION_FLT_UNDERFLOW</i> &ndash; операция с плавающей запятой вызвала антипереполнение;</li>

<li>
<i>EXCEPTION_INT_DIVIDE_BY_ZERO</i> &ndash; попытка деления на ноль в операциях с целыми;</li>

<li>
<i>EXCEPTION_INT_OVERFLOW</i> &ndash; результат целочисленной операции вызвал переполнение;</li>

<li>
<i>EXCEPTION_PRIV_INSTRUCTION</i> &ndash; попытка выполнить команду недопустимую для текущего режима;</li>

<li>
<i>EXCEPTION_IN_PAGE_ERROR</i> &ndash; попытка обращения к неизвестной странице;</li>

<li>
<i>EXCEPTION_ILLEGAL_INSTRUCTION</i> &ndash; попытка выполнения недопустимой инструкции;</li>

<li>
<i>EXCEPTION_NONCONTINUABLE_EXCEPTION</i> &ndash; попытка продолжить выполнение команд, после возникновения исключение не позволяющее этого;</li>

<li>
<i>EXCEPTION_STACK_OVERFLOW</i> &ndash; переполнение стека;</li>

</ul>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Таким образом, предопределенные исключения достаточно подробно представляют ошибки, обнаруживаемые операционной системой.</p>



<br>
<br>
<div class="header">
<a name="2_5"></a>2.5.	Кадрированное управление исключениями</div>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Синтаксис определения кадрированного управления исключениями:</p>


<pre>
<div class="code">
__try
{
  // Операторы контролируемого блока
}
__except(выражение_фильтра)
{
// Операторы блока обработки исключения
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Блок обработки исключения можно рассматривать как условный оператор, где решение о продолжении процесса определяется вычисляемым после порождения исключения выражением фильтра.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Выражение фильтра может принимать одно из значений:</p>

<ul>

<li>
<i>EXCEPTION_EXECUTE_HANDLER</i> (1) &ndash; обработать исключение;</li>

<li>
<i>EXCEPTION_CONTINUE_SEARCH</i> (0) &ndash; продолжение поиска обработчика исключения на предшествующем уровне вложенности оператора <i>__try</i>;</li>

<li>
<i>EXCEPTION_CONTINUE_EXECUTION</i> (-1) &ndash; возврат управления в точку выброса исключения.</li>

</ul>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Как в выражении фильтра, так и в блоке обработки исключения можно получить детальную информацию о причине исключения, вызывая функции</p>


<pre>
<div class="code">
DWORD GetExceptionCode(VOID);

LPEXCEPTION_POINTERS GetExceptionInformation(VOID);
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Функция <i>GetExceptionCode()</i> возвращает код исключения, а <i>GetExceptionInformation()</i> &ndash; указатель на структуру <i>EXCEPTION_POINTERS</i>, которая представляет собой детальное описание исключения.</p>


<br>
<br>
<div class="header">
<a name="2_6"></a>2.6.	Завершающее управление исключениями</div>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Синтаксис определения завершающего управления исключениями:</p>


<pre>
<div class="code">
__try
{
  // Операторы контролируемого блока
}
__finally
{
  // Операторы блока обработки факта завершения
  // контролируемого блока
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Завершение контролируемого блока может быть нормальным или преждевременно прерванным. Причины досрочного выхода:</p>

<ul>

<li>выполнение оператора <i>return</i>, <i>goto</i>, <i>break</i> или <i>continue</i>;</li>

<li>вызов функции, подобной <i>longjump()</i>;</li>

<li>порождение исключения.</li>

</ul>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Любой исход завершения контролируемого блока, безусловно приводит к гарантированному выполнению операторов блока <i>__finally</i>. Очевидно, что допускается совмещение кадрированного и завершающего управления исключениями. Например:</p>


<pre>
<div class="code">
void main()
{
  puts("Начало программы");
  int *p = 0x00000000; // Пустой указатель !

  __try
  {
    puts("Начало блока контроля исключения");
    __try
    {
      puts("Начало блока контроля завершения");
      puts("Попытка нарушения защиты памяти...");
      *p = 13;
      puts("Продолжение работы");
    }
    __finally
    {
      puts("Блок завершения активен");
    }
    puts("Конец блока контроля исключения");
  }
  __except(puts("Фильтр активен"), 1)
  {
    puts("Исключение обработано");
  }
  puts("Завершение программы");
}
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Результаты работы программы:</p>


<pre>
<div class="code">
Начало программы
Начало блока контроля исключения
Начало блока контроля завершения
Попытка нарушения защиты памяти...
Фильтр активен
Блок завершения активен
Исключение обработано
Завершение программы
</div>
</pre>


<br>
<br>
<div class="title">
<a name="3"></a>3.	ИНДИВИДУАЛЬНЫЕ ЗАДАНИЯ</div>

<br>
<br>
<div class="header">
<a name="|||||"></a>Варианты заданий</div>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>1)</b>	Создайте иерархию классов для представления исключений математических операций. Например:</p>


<pre>
<div class="code">
//математические исключения
class MathException
{
	char op_name[20]; //имя операции
	long val1; //значение левого операнда операции
	long val2; //значение правого операнда операции
public:
	MathException(char * name_op, long v1, long v2);
	virtual char * Message() = 0;
};
//переполнение сверху
class OverflowException : public MathException {/*...*/};
//переполнение сверху
class UnderflowException : public MathException {/*...*/};
//деление на 0
class ZdivideException : public MathException {/*...*/};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			В производных классах необходимо определить конструкторы и переопределить функцию <b>Message()</b>, которая должна возвращать информацию о произошедшей ошибке.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Разработайте класс</p>


<pre>
<div class="code">
class Math
{
public:
	long Add(long a, long b); //сложение (a + b)
	long Sub(long a, long b); //вычитание (a - b)
	long Mul(long a, long b); //умножение (a * b)
	long Div(long a, long b); //деление (a / b)
	long Mod(long a, long b); //остаток от деления (a % b)
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Каждая функция должна отслеживать исключительные ситуации при выполнении операций и генерировать исключение соответствующего типа.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			В функции <b>main</b> поместите в блоки <b>try...catch()</b> вызовы функций с различными операндами.</p>
 

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>2)</b>	Создайте иерархию классов для представления исключений файловых операций. Например:</p>


<pre>
<div class="code">
//файловые исключения
class FileException
{
	HANDLE hfile[30];	//дескриптор файла
	char filename[256];	//имя файла
public:
	FileException(char * fname);
	FileException(HANDLE hf);
	virtual char * Message() = 0;
};
//ошибка при создании файла
class CreateException : public FileException {/*...*/};
//ошибка открытия файла
class OpenException : public FileException {/*...*/};
//ошибка чтения
class ReadException : public FileException {/*...*/};
//ошибка записи
class WriteException : public FileException {/*...*/};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			В производных классах необходимо определить конструкторы и переопределить функцию Message(), которая должна возвращать информацию о произошедшей ошибке.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Разработайте класс</p>


<pre>
<div class="code">
#include &lt;windows.h&gt;
class File
{
	HANDLE CreateFile(char *);//создание нового файла (R/W)
	HANDLE OpenFile(char *);  //открытие существующего файла (R/W)
//чтение данных из файла
	void ReadFile(HANDLE hf, void * buf, int count);
//запись данных в файл
	void WriteFile(HANDLE hf, void * buf, int count);
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Каждая функция должна отслеживать исключительные ситуации при выполнении операций и генерировать исключение соответствующего типа.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			В функции <b>main</b> поместите в блоки <b>try...catch()</b> вызовы функций класса <b>File</b>.</p>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			<b>3)</b>	Создайте иерархию классов для представления исключений трансцендентных операций. Например:</p>


<pre>
<div class="code">
//трансцендентные исключения (см задание 1)
class TranscException
{
	double value;
	char opname[20];
public:
	TranscException(char * nameop, double val);
	virtual char * Message() = 0;
};
//исключения логарифмических функций
class LogException : public TranscException;
//исключения тригонометрических функций
class TrigException : public TranscException;
Разработайте класс
class Trans
{
public:
	double Sin(double angle); //синус
	double Cos(double angle); //косинус
	double Tan(double angle); //тангенс
	double Asin(double sn);   //арксинус
	double Acos(double cs);   //арккосинус
	double Atan(double tg);   //арктангенс
	double Ln(double value);  //натуральный логарифм
	double Lg(double value);  //десятичный логарифм
};
</div>
</pre>


<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			Каждая функция должна отслеживать исключительные ситуации при выполнении операций и генерировать исключение соответствующего типа.</p>

<p>
			&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
			В функции <b>main</b> поместите в блоки <b>try...catch()</b> вызовы функций с различными операндами.</p>

<center>[<a href="lab6.html">Предыдущая работа</a>][<a href="#0">Оглавление</a>][<a href="index.html">Содержание</a>][<a href="lab8.html">Следующая работа</a>]</center>



</body>
</html>
