<!DOCTYPE html>
<html>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<head>
<script>
 var delay=15;
 var i_delta=5;
</script>
<title>Тестирование уровня знаний</title>
<p><a name="topfrm"></a></p>
<p><b>Тест № <span id="test_nmb">?</span>. Выделите имеющие отношения к вопросам понятия</b>
</head>
<body>

<form id = "myForm">  </form>

<input type = "button" value = "Оценка текущая" onclick = "test0Function()">
<input type = "button" value = "Оценка теста" onclick = "test1Function()">
<input type = "button" value = "Другой тест" onclick = "nextFunction()">
 
<p><a name="bottom"></a></p>
<p id="demo"></p>

<script>

var arrObjects = [{
 q: "Какие виды моделей не обязательно отражают жизненный цикл программ?",
 a: "1) водопадная модель; *2) реляционная модель; 3) итеративная модель; *4) сетевая модель; *5) имитационная модель."},{
 q: "Какую роль не исполняет язык UML?",
 a: "1) язык моделирования; *2) язык программирования; 3) язык документирования проектов; 4) спецификация проекта; 5) визуализация проекта."},{
 q: "Какие типовые решения не представляет язык UML?",
 a: "1) шаблоны проектирования; *2) идиомы программирования; 3) определение иерархии классов; *4) анти-шаблоны проектирования; *5) социальные анти-шаблоны."},{
 q: "Что не определяют диаграммы UML?",
 a: "1) задачи прямого проектирования; 2) задачи обратного проектирования; *3) задачи оптимизации кода; *5)       задачи рефакторинга."},{
 q: "Что отражает диаграмма прецедентов?",
 a: "*1) функциональные требования; 2) нефункциональные требования; 3) сценарий поведения системы; 4) структуру системы; 5) поведение системы."},{ 
 q: "В чем различие понятий операции и метода в объектных моделях?",
 a: " 1) понятия взаимозаменяемы; *2) операция объявления функции; *3) определение (тело) функции; 4) такие понятия отражают варианты перевода; 5) понятия являются синонимами функции-члена класса."},{
 q: "Какие из перечисленных диаграмм не отражают динамику поведения системы?",
 a: "*1) диаграмма развертывания; 2) диаграмма активности; 3) диаграмма кооперации; 4) диаграмма объектов; 5) временная диаграмма."},{
 q: "Какие из перечисленных диаграмм не отражают агрегирование и композицию объектов?",
 a: " 1) диаграмма классов; *2) диаграмма активности; *3) диаграмма кооперации; 4) диаграмма объектов; 5) диаграмма взаимодействия."},{
 q: "Как можно реализовать динамическую классификацию свойств?",
 a: "*1) использование ассоциации типа и состояния; 2) использование динамической идентификации типа; 3) использование полиморфизма; 4) использование шаблона коллекции; 5) использование шаблонного метода."},{
 q: "Как отображается различие видов сообщений на диаграммах UML?",
 a: "*1) формами стрелок; 2) текстовыми фразами; 3) классами ассоциаций; 4) UML не имеет средств отображения различий видов сообщений; 5) специальными пиктограммами."},{
 q: "Какие понятия UML используются для отражения обработки вложенных исключений?",
 a: "*1) регионы прерываемой деятельности; *2) узлы обработчиков исключений диаграммы деятельности; 3) диаграмма активности; 4) UML не поддерживает обработку исключений; 5) области расширения диаграммы деятельности."},{
 q: "Какие элементы диаграмм деятельности не отражают состояние параллельных процессов моделируемой системы?",  a: " 1) маркеры потоков данных; 2) маркеры потоков управления; 3) центральный буфер и хранилище данных; 4) узлы объектов; *5) узлы управления."},{
 q: "Что из перечисленных понятий поддерживается моделью протокольного конечного автомата?", 
 a: " *1) контекст классификатора; 2) контекст характеристики поведения; 3) непротокольные переходы;  4) действия входа, выхода или  внутренней деятельности; 5) псевдо-состояния глубокой или неглубокой истории."},{
 q: "Какие средства моделирования собственного поведения классификатора описывают изменение состояний отдельных объектов с течением времени?",
 a: "*1) диаграммы конечного автомата; 2) диаграммы деятельности; 3) узлы управления; 4) маркеры потоков данных; 5) диаграммы конечных автоматов."},{
 q: "Какие средства моделирования  отражают взаимодействие объектов или линий жизни при реализации функциональности системы?",
 a: " 1) диаграммы конечного автомата; *2) различные диаграммы взаимодействия; 3) диаграммы деятельности; 4) диаграммы объектов; 5) временные диаграммы."},{
 q: "Какие средства моделирования  отражают деятельность в форме последовательности действий различных элементов системы?",
 a: " 1) диаграммы конечного автомата; *2) диаграммы деятельности; *3) диаграммы объектов; 4) диаграммы прецедентов; 5) временные диаграммы."},{
 q: "Что не нарушает принципы объектного подхода в коде программы?",
 a: " 1) сложный оператор switch или последовательность вложенных условных операторов; 2) временные поля,  которые нужны объекту только при определённых обстоятельствах, оставаясь пустыми в остальное время; 3) отказ от наследства - подкласc использует лишь малую часть унаследованных методов и свойств суперкласса, при этом ненужные методы могут просто не использоваться либо быть переопределёнными и выбрасывать исключения; 4) альтернативные классы с разными интерфейсами, когда такие классы выполняют одинаковые функции, но имеют разные названия методов; *5) множественное наследование."},{
 q: "Шаблон \"Хранитель\" (Memento):", 
 a: "*1) не нарушая инкапсуляцию, определяет и сохраняет внутреннее состояние объекта; 2) позволяет восстановить объект в любом состоянии; 3) создает интерфейс с базой данных; 4) реализует понятие хранилища диаграммы деятельности; 5) представляет реализации операций сериализации или маршалинга."},{
 q: "Назначение шаблона Цепочка обязанностей (Chain of responsibility)?",
 a: "*1) избегает связывания отправителя запроса с его получателем, давая возможность обработать запрос более, чем одному объекту; *2) связывает объекты-получатели и передаёт запрос по цепочке, пока объект не обработает его; 3) реализует кооперацию объектов; 4) является элементом контроллера страниц; 5) моделирует поведение строителя."},{
 q: "Как структурировать простую логику домена?",
 a: "*1) сценарий транзакции (Transaction Script); 2) диаграмма последовательности; 3) ненужная сложность; 4) отображение с помощью таблицы ассоциаций; 5) функция для галочки."},{
 q: "Как структурировать сложную логику домена?",
 a: "*1) модель предметной области (Domain Model); 2) диаграмма последовательности; 3) ненужная сложность; 4) сценарий транзакции; 5) инверсия абстракции."},{
 q: "Как структурировать логику домена, когда среда разработки содержит достаточно средств для манипулирования множеством записей (Record Set)?",
 a: "*1) модуль таблицы (Table Module); 2) диаграмма последовательности; 3) ненужная сложность; 4) отображение с помощью таблицы ассоциаций; 5) инверсия абстракции."},{
 q: "Как снабдить логику домена отчетливым интерфейсом программирования приложений?",
 a: "*1) слой служб (Service Layer); 2) ненужная сложность; 3) фасад; 4) коллекция команд; 5) абстрактная фабрика."},{
 q: "Как структурировать процесс представления данных в Web?",
 a: "*1) модель-представление-контроллер (Model View Controller); 2) диаграмма последовательности; 3) отображение с помощью таблицы ассоциаций; 4) диаграмма деятельности; 5) инверсия абстракции."},{
 q: "Как организовать обработку HTTP-запросов в случае, когда каждый  адрес URL соответствует отдельному документу Web-сервера?",
 a: "*1) контроллер страниц (Page Controller); 2) диаграмма последовательности; 3) диаграмма деятельности; 4) контроллер запросов; 5) конечный автомат."},{
 q: "Как организовать обработку HTTP-запросов в случае сложных потоков функций приложения?",
 a: "*1) контроллер запросов (Front Controller); 2) кодирование путём исключения; 3) диаграмма деятельности; 4) динамическая или множественная классификация; 5) конечный автомат."},{
 q: "Как организовать обработку HTTP-запросов в случае необходимости поддержка пользователей из других стран или гибкие политики безопасности?",
 a: "*1) контроллер запросов (Front Controller); 2) диаграмма деятельности; 3) конечный автомат; 4) динамическая или множественная классификация; 5) полиморфизм."},{
 q: "Как управлять форматированием Web-страниц посредством маркеров для отображения динамических данных?",
 a: "*1) представление по шаблону (Template View); 2) кодирование путём исключения; 3) диаграмма деятельности; 4) контроллер запросов; 5) конечный автомат."},{
 q: "Как управлять форматированием Web-страниц, рассматриваемых как результат преобразования данных домена (возможно, находившихся в формате XML)?",
 a: "*1) представление с преобразованием (Transform View); 2) кодирование путём исключения; 3) представление по шаблону; 4) диаграмма деятельности; 5) контроллер запросов."},{
 q: "Как управлять форматированием Web-страниц при необходимости подвергнуть глобальным изменениям внешний вид и поведение сайта?",
 a: "*1) двухэтапное представление (Two Step View); 2) представление по шаблону; 3) частный случай; 4) диаграмма деятельности; 5) контроллер запросов."},{
 q: "Как управлять форматированием Web-страниц так, чтобы один и тот же логический экран имел несколько различных представлений?",
 a: "*1) двухэтапное представление (Two Step View); 2) кодирование путём исключения; 3) представление по шаблону; 4) диаграмма деятельности; 5) нет общего решения."},{
 q: "Как управлять сложным потоком функций приложения?",
 a: "*1) контроллер приложения (Application Controller); 2) отделенный интерфейс; 3) диаграмма деятельности; 4) контроллер запросов; 5) приспособленец."},{
 q: "Как взаимодействовать с базой данных в случае использования сценария транзакции (Transaction Script)?",
 a: "*1) шлюз записи данных (Row Data Gateway); 2) шлюз таблицы данных; 3) активная запись; 4) мост; 5) приспособленец."},{
 q: "Как взаимодействовать с базой данных в случае использования платформы с хорошей поддержкой множества записей (Record Set)?",
 a: "*1) шлюз таблицы данных (Table Data Gateway); 2) однопоточное выполнение; 3) шлюз записи данных; 4) призрак; 5) приспособленец."},{
 q: "Как взаимодействовать с базой данных в случае, когда структура модели предметной области (Domain Model) в точности соответствует таблицам базы данных?",
 a: "*1) активная запись (Active Record); 2) шлюз записи данных; 3) выполняет посредник; 4) контроллер запросов; 5) приспособленец."},{
 q: "Как взаимодействовать с базой данных в случае, когда модель предметной области (Domain Model) довольно сложна?",
 a: "*1) преобразователь данных (Data Mapper); 2) выполняет посредник; 3) активная запись; 4) контроллер запросов; 5) однопоточное выполнение."},{
 q: "Как взаимодействовать с базой данных в случае использования модуля таблицы (Table Module)?",
 a: "*1) шлюз таблицы данных (Table DataGateway); 2) однопоточное выполнение; 3) шлюз записи данных; 4) выполняет посредник; 5) приспособленец."},{
 q: "Как гарантировать, что одни и те же данные не будут загружены в несколько разных объектов приложения?",
 a: "*1) коллекция объектов (Identity Map; 2) кодирование путем исключения; 3) посредник; 4) преобразователь данных; 5) приспособленец."},{
 q: "Как сохранить связь объектов домена с соответствующими записями базы данных?",
 a: "*1) поле идентификации (Identity Field); 2) внедренное значение; 3) контроллер запросов; 4) конечный автомат; 5) приспособленец."},{
 q: "Как сократить объем кода отображения объектов домена на базу данных?",
 a: "*1) отображение метаданных (Metadata Mapping); 2) ненужная сложность; 3) самоуничтожение; 4) кодирование путем исключения; 5) приспособленец."},{
 q: "Как сформулировать запрос к базе данных в терминах модели предметной области (Domain Model)?",
 a: "*1) объект запроса (Query Object); 2) ненужная сложность; 3) сценарий транзакции; 4) контроллер запросов; 5) приспособленец."},{
 q: "Как сохранить связи между объектами в базе данных в случае наличия ссылки на один объект?",
 a: "*1) отображение внешних ключей (Foreign Key Mapping); 2) внедренное значение; 3) выполняет посредник; 4) отображение с помощью таблицы ассоциаций; 5) отображение зависимых объектов."},{
 q: "Как сохранить связи между объектами в базе данных в случае наличия ссылки на коллекцию объектов?",
 a: "*1) отображение внешних ключей (Foreign KeyMapping); 2) выполняет посредник; 3) отображение с помощью таблицы ассоциаций; 4) отображение зависимых объектов; 5) приспособленец."},{
 q: "Как сохранить связи между объектами в базе данных в случае наличия отношения типа \"многие ко многим\"?",
 a: "*1) отображение с помощью таблицы ассоциаций (Association Table Mapping); 2) отображение зависимых объектов; 3) контроллер запросов; 4) конечный автомат; 5) приспособленец."},{
 q: "Как сохранить связи между объектами в базе данных в случае наличия коллекции объектов, которые используются только в контексте другого объекта?",
 a: "*1) отображение зависимых объектов (Dependent Mapping); 2) выполняет посредник; 3) отображение с помощью таблицы ассоциаций; 4) кодирование путем исключения; 5) приспособленец."},{
 q: "Как сохранить связи между объектами в базе данных в случае наличия поля, в котором хранится объект-значение (Value Object)?",
 a: "*1) внедренное значение (Embedded Value); 2) выполняет посредник; 3) отображение зависимых объектов; 4) отображение с помощью таблицы ассоциаций; 5) приспособленец."},{
 q: "Как сохранить связи между объектами в базе данных в случае наличия сложной сети объектов, которые не используются другими частями базы данных?",
 a: "*1) сериализованный крупный объект (SerializedLOВ); 2) выполняет посредник; 3) отображение с помощью таблицы ассоциаций; 4) отображение зависимых объектов; 5) приспособленец."},{
 q: "Как избежать загрузки в оперативную память всего содержимого базы данных?",
 a: "*1) загрузка по требованию (Lazy Load); 2) ненужная сложность; 3) самоуничтожение; 4) кодирование путем исключения; 5) приспособленец."},{
 q: "Как сохранить структуры наследования в реляционной базе данных?",
 a: "*1) наследование с одной таблицей (Single Table Inheritance); 2) наследование с таблицами для каждого конкретного класса; 3) наследование с таблицами для каждого класса; 4) отображение с помощью таблицы ассоциаций; 5) приспособленец."},{
 q: "Как сохранить структуры наследования в реляционной базе данных без создания высокой конкуренции за право доступа к таблице?",
 a: "*1) наследование с таблицами для каждого класса (Class Table Inheritance); 2) наследование с одной таблицей; 3) наследование с таблицами для каждого конкретного класса; 4) отображение с помощью таблицы ассоциаций; 5) приспособленец."},{
 q: "Как сохранить структуры наследования в реляционной базе данных без бессмысленной траты свободного места?",
 a: "*1) наследование с таблицами для каждого класса (Class Table Inheritance); 2) наследование с одной таблицей; 3) наследование с таблицами для каждого конкретного класса; 4) отображение с помощью таблицы ассоциаций; 5) приспособленец."},{
 q: "Как сохранить структуры наследования в реляционной базе данных, когда при выполнении запросов требуется большое число соединений?",
 a: "*1) наследование с таблицами для каждого конкретного класса (Concrete Table Inheritance); 2) наследование с одной таблицей; 3) наследование с таблицами для каждого класса; 4) класс данных; 5) отображение с помощью таблицы ассоциаций."},{ 
 q: "Как отслеживать считывание и изменение объектов?",
 a: "*1) единица работы (Unit of Work); 2) призрак; 3) кодирование путём исключения; 4) контроллер запросов; 5) нет общего решения."},{
 q: "Как зафиксировать  сделанные изменения в базе данных в рамках одного клиентского запроса?",
 a: "*1) оптимистическая автономная блокировка (Optimistic Offline Lock); 2) однопоточное выполнение; 3) контроллер запросов; 4) конечный автомат; 5) приспособленец."},{
 q: "Как гарантировать отсутствие потерь результатов проделанной работы пользователя?",
 a: "*1) пессимистическая автономная блокировка (Pessimistic Offline Lock); 2) однопоточное выполнение; 3) кодирование путем исключения; 4) протокольный конечный автомат; 5) приспособленец."},{
 q: "Как наложить общую блокировку на группу взаимосвязанных объектов?",
 a: "*1) блокировка с низкой степенью детализации (Coarse-GrainedLock); 2) контроллер запросов; 3) конечный автомат; 4) диаграмма деятельности; 5) нет общего решения."},{
 q: "Как гарантировать выполнение всех необходимых действий по наложению и снятию блокировки?",
 a: "*1) неявная блокировка (Implicit Lock); 2) однопоточное выполнение; 3) кодирование путем исключения; 4) контроллер запросов; 5) приспособленец."},{
 q: "Как осуществлять удаленный доступ к объектам, имеющим интерфейс с высокой степенью детализации?",
 a: "*1) интерфейс удаленного доступа (Remote Facade); 2) однопоточное выполнение; 3) контроллер запросов; 4) конечный автомат; 5) приспособленец."},{
 q: "Как передать содержимое нескольких объектов в одном удаленном вызове?",
 a: "*1) объект переноса данных (Data Transfer Object); 2) коллекция; 3) сериализация; 4) маршалинг; 5) сообщение."},{
 q: "Как сохранить промежуточное состояние сеанса с небольшим количеством данных в процессе выполнения транзакции?",
 a: "*1) сохранение состояния сеанса на стороне  клиента (Client Session State); 2) сохранение состояния сеанса на стороне сервера (Server Session State); 3) сохранение состояния сеанса в базе данных (Database Session State); 4) объект переноса данных; 5) внедренное значение."},{
 q: "Как сохранить промежуточное состояние сеанса с большим количеством данных в процессе выполнения транзакции?",
 a: " 1) сохранение состояния сеанса на стороне  клиента (Client Session State); *2) сохранение состояния сеанса на стороне сервера (Server Session State); 3) сохранение состояния сеанса в базе данных (Database Session State); 4) объект переноса данных; 5) внедренное значение."},{
 q: "Как сохранить промежуточное состояние сеанса с базами данных в процессе выполнения транзакции?",
 a: " 1) сохранение состояния сеанса на стороне  клиента (Client Session State); 2) сохранение состояния сеанса на стороне сервера (Server Session State); *3) сохранение состояния сеанса в базе данных (Database Session State); 4) объект переноса данных; 5) внедренное значение."},{
 q: "Какие обязанности класса не относятся к знаниям объекта?",
 a: " 1) наличие информации о закрытых инкапсулированных данных; 2)  наличие информации о связанных объектах; 3)  наличие информации о следствиях или вычисляемых величинах; *4) диаграмма объектов; *5) диаграмма классов."},{
 q: "Какие обязанности класса не относятся к действиям объекта?",
 a: " 1)  выполнение некоторых действий самим объектом, например, создание экземпляра или выполнение вычислений; 2)  инициирование действий других объектов; 3)  управление действиями других объектов и их координирование; *4) диаграмма объектов; *5) диаграмма классов."},{
 q: "Что гарантирует, что класс имеет поименованные экземпляры объекта и обеспечивает глобальную точку доступа к ним?",
 a: "*1) пул одиночек (Multiton); 2) коллекция; 3) одиночка; 4) реестр; 5) объектный пул."},{
 q: "Какой класс представляет собой интерфейс для работы с набором инициализированных и готовых к использованию объектов?",
 a: "*1) объектный пул (Object pool); 2) пул одиночек; 3) коллекция; 4) реестр; 5) объектная клоака."},{
 q: "Где получение некоторого ресурса совмещается с инициализацией, а освобождение - с уничтожением объекта?",
 a: "*1) получение ресурса есть инициализация (Resource acquisition is initialization (RAII)); 2) класс с конструктором и деструктором; 3) ленивая загрузка; 4) ленивый класс; 5) ленивая инициализация."},{
 q: "Что обеспечивает общую функциональность группе классов?",
 a: "*1) слуга(Servant); *2) единое дерево наследования; 3) делегирование; 4) полиморфизм; 5) фабричный метод."},{
 q: "Что обеспечивает связывание бизнес-логики?",
 a: "*1) спецификация (Specification); 2) единое дерево наследования; 3) делегирование; 4) полиморфизм; 5) диаграмма деятельности."},{
 q: "Как реализуется элементарная стратегия решения задачи?",
 a: "*1) простая политика (Simple Policy); 2) cтратегия (Strategy); 3) наследуемая операция; 4) виртуальная операция; 5) статический метод класса."},{
 q: "Шаблон \"Прослушиватель событий\" (Event listener)?",
 a: "*1) получает уведомлений о событиях; 2) является интерфейсом фасада; 3) базовый класс контроллера  заявок; 4) использует однопоточное выполнение(Single thread execution); 5) является фасадом пула потоков."},{
 q: "Шаблон \"Одноразовый посетитель\" (Single-serving visitor)?",
 a: "1) оптимизирует реализацию шаблона \"Посетитель\", который инициализируется, единожды используется и удаляется; *2) реализует поток объектов диаграммы деятельности; 3) отражает процесс передачи сообщений; 4) используется при реализации цепочки обязанностей; 5) используется при реализации строителя."},{
 q: "Шаблон \"Иерархический посетитель\" (Hierarchical visitor)?",
 a: "*1) предоставляет способ обхода всех вершин иерархической структуры данных;  2) реализует поток объектов диаграммы деятельности; 3) отражает процесс передачи сообщений; 4) используется при реализации цепочки обязанностей; *5) используется при реализации строителя."},{
 q: "Что обеспечит выполнение действия над объектом только тогда, когда тот находится в корректном состоянии?",
 a: "*1) обход (Balking); 2) критическая секция; 3) протокольный конечный  автомат; 4) диаграмма последовательности; 5) блокировка."},{
 q: "Как использовать несколько наблюдателей для обеспечения синхронизации свойств в различных объектах?",
 a: "*1) связанные свойства (Binding properties); 2) пул объектов;  3) цепочка обязанностей; 4) диаграмма деятельности; 5) планировщик."},{
 q: "Что позволяет компонентам и приложениям обмениваться информацией (сообщениями)?",
 a: " 1) обмен сообщениями (Messaging pattern); 2) файловый обмен; *3) удаленный вызов процедур; 4) общая база данных; 5) общая разделяемая память."},{
 q: "Как уменьшить накладные расходы, связанные с получением блокировки?",
 a: "*1) блокировка с двойной проверкой (Double checked locking); 2) однопоточное выполнение; 3) цепочка обязанностей; 4) диаграмма деятельности; 5) планировщик."},{
 q: "Что решает адресные проблемы в программах с несколькими потоками?",
 a: "*1) асинхронный шаблон(Event-Based Asynchronous);  2) наблюдатель; 3) память потоков  (Thread-Specific Storage); 4) однопоточное выполнение; 5) объектный пул."},{
 q: "Как блокировать  выполнение действия над объектом тогда, когда тот находится в корректном состоянии?",
 a: "*1) охраняемая приостановка (Guarded suspension); 2) наблюдатель; 3) конечный автомат; 4) блокировка; 5) планировщик."},{
 q: "Что блокирует ресурс для предотвращения доступа или изменения его другими потоками?",
 a: "*1) блокировка (Lock); 2) охраняемая приостановка (Guarded suspension); 3) конечный автомат; 4) наблюдатель; 5) монитор."},{
 q: "Шаблон \"Монитор\" (Monitor):",
 a: "*1) предназначен для безопасного использования более, чем одним потоком (аналог комнаты с единственным ключом); 2) реализует цепочку обязанностей; 3) реализует контроллер запросов;  4) наследует прослушиватель событий;  5) использует неявную блокировку."},{
 q: "Шаблон \"Реактор\" (Reactor):",
 a: "*1) предназначен для синхронной передачи запросов сервису от одного или нескольких источников; 2) является монитором передачи сообщений; 3) реализует цепочку  обязанностей; 4) использует наблюдатель; 5) использует неявную блокировку."},{
 q: "Что позволяет нескольким потокам одновременно считывать информацию из общего хранилища, позволяя только одному потоку в текущий момент времени её изменять?",
 a: "*1) блокировка чтения/записи (Read/write lock); 2) охраняемая приостановка(Guarded suspension); 3) конечный автомат; 4) наблюдатель; 5) монитор."},{
 q: "Шаблон \"Планировщик\" (Scheduler):",
 a: "*1) обеспечивает механизм реализации политики планирования, не зависящий ни от одной конкретной политики; 2) реализует стратегию управления пулом потоков; 3) является монитором событий; 4) интенсивно использует рефлексивные сообщения; 5) реализует цепочку обязанностей."},{
 q: "Что предоставляет множество потоков для независимой параллельной обработки заданий из очереди?",
 a: "*1) пул потоков (Thread pool);  2) цепочка обязанностей; 3) планировщик; 4) монитор; 5) диаграмма деятельности."},{
 q: "Что обеспечивает предоставление глобальных разделяемых переменных для разных потоков?",
 a: "*1) память потоков (Thread-Specific Storage); 2) критические секции; 3) однопоточное выполнение; 4) одиночка; 5) объектный пул."},{
 q: "Шаблон \"Однопоточное выполнение\" (Single thread execution):",
 a: "*1) препятствует конкурентному вызову метода; *2) запрещает параллельное выполнение метода; 3) реализует операции одиночек; 4) реализует обработку событий конечного автомата;  5) обеспечивает корректности использования критических секций кода."},{
 q: "Кооперативный шаблон (Cooperative pattern):",
 a: "*1) обеспечивает механизм безопасной остановки потоков исполнения; *2) использует общий флаг для сигнализации прекращения работы потоков; 3) реализует диаграмму кооперации; 4) реализует пул объектов; 5) реализует коллекцию."},{
 q: "Основные причины перестройки кода (рефакторинга) программной системы:",
 a: "*1) необходимо добавить новую функцию без изменения архитектуры системы; *2)  необходимо исправить ошибку, для которой причины возникновения сразу не ясны; *3)  преодоление трудностей в командной разработке, обусловленных сложной логикой программы; 4) проведение оптимизации системы; 5) расширение  функциональности и архитектуры (реинжиниринг) системы."},{
 q: "Какой метод взаимодействия практически пригоден для  стихийной интеграции систем?",
 a: "*1) взаимодействие \"точка-точка\";  2) взаимодействие \"звезда\"; 3) смешанное взаимодействие; 4) реинжиниринг взаимодействующих систем;  5) выбор стандарта протокола взаимодействия."},{
 q: "Какому из анти-шаблонов соответствует вынесение новой функциональности в отдельное приложение вместо расширения уже имеющегося?",
 a: "*1) два туннеля; 2) изобретение квадратного колеса; 3) вклад; 4) противоречивые процессы; 5) инерция кода."},{
 q: "Какому из анти-шаблонов соответствует боязнь размещать логику в объектах предметной области?",
 a: "*1) анемичная (слабая) модель; 2) зона  дружбы;  3) приватизация; 4) золотой теленок; 5) мягкое кодирование."},{
 q: "Какому из анти-шаблонов соответствует неожиданное взаимодействие между широко разделёнными частями системы?",
 a: "*1) действие на расстоянии; 2) зона  дружбы;  3) слепая вера; 4) таинственный код; 5) ад зависимостей."},{
 q: "Какому из анти-шаблонов соответствует  выделение непропорционально больших усилий в фазе анализа проекта?",
 a: "*1) аналитический паралич; 2) продолжительное устаревание;  3) слепая вера; 4) преждевременная оптимизация; 5) расползание рамок."},{
 q: "Что такое асинхронное сообщение?",
 a: " 1) аналог рефлексивного сообщения;  2) сообщение, отправляемое одновременно с сообщениями от других объектов; *3) сообщение, на которое не ожидается ответ после посылки; 4) сообщение, которое приостанавливает поток выполнения до получен ответа; 5) сообщение, отправляемое объектом в ответ на полученное сообщение."},{
 q: "Какие из перечисленных ситуаций могут потребовать использование диаграмм активностей?",
 a: "*1) уточнение диаграмм прецедентов; 2) моделирование одновременного выполнения приложений; 3) отслеживание изменения состояния объекта; 4) отображение последовательности сообщений; *5) моделирование выполнения операций."},{
 q: "Какие из перечисленных функций реализует  модульное тестирование?",
 a: "*1) проверка функционирования каждого независимого программного модуля; 2) максимальная изоляция побочного влияния на функционирование модуля со стороны остальных частей системы; 3) тестирование модуля в условиях отсутствия пользователя; 4) проверка функционирования одного участка программного кода; 5) оценка качества реализации кода; 5) проверка функционирования обновленных модулей."},{
 q: "Шаблон \"Информационный эксперт\" (Information Expert):",
 a: "*1) выполнение обязанностей назначается классу, имеющему информацию, которая необходима для выполнения обязанности; 2) обладает информацией о знаниях класса; 3) обладает информацией о действиях класса; 4) имеет право доступа к элементам класса; 5) находится в зоне дружбы."},{
 q: "Шаблон \"Создатель\" (Creator):",
 a: "*1) содержит или агрегирует объекты создаваемого класса; *2) обладает данными инициализации  объекта создаваемого класса; *3) записывает экземпляры объектов создаваемого класса; *4) активно использует объекты создаваемого класса; 5) божественный объект."},{
 q: "Шаблон \"Контроллер\" (Controller):",
 a: " 1) обработчик системных сообщений; *2) класс представляет всю систему, устройство или подсистему в целом (внешний контроллер); *3) класс представляет некоторый сценарий прецедента, в процессе выполнения которого происходят системные события (контроллер прецедента или сеанса); 4) планировщик; 5) элемент реализации цепочки обязанностей."},{
 q: "Как обеспечить низкую зависимость классов и повысить возможность их повторного использования?",
 a: "*1) распределить обязанностей так, чтобы степень связанности оставалась низкой; *2) низкая связанность (Low Coupling); 3) делегирование; 4) динамическая классификация; 5) удаленный вызов процедур."},{
 q: "Как распределить обязанности таким образом, чтобы степень зацепления оставалась высокой?",
 a: "*1) высокое зацепление (High Cohesion); 2) наследование с таблицами для каждого класса; 3) делегирование;4) динамическая классификация; 5) удаленный вызов процедур."},{
 q: "Шаблон \"Полиморфизм\" (Polymorphism):",
 a: "*1) обязанности распределяются для различных вариантов поведения; *2) использование полиморфных операций класса; *3) принцип объектно-ориентированной технологии; 4) инверсия абстракции; 5) ненужная сложность."},{
 q: "Шаблон \"Искусственный\" (Pure Fabrication):",
 a: "*1) для реализации без проблем  шаблонов High Cohesion и Low Coupling  создается искусственный класс, не представляющий конкретное понятие из предметной области; *2) средство поддержки высокого зацепления, слабого связывания и повторного использования; 3) заглушка; 4) анемичная модель; 5) ненужная сложность."},{
 q: "Шаблон \"Перенаправление\" (Indirection):",
 a: "*1) обеспеченние связи между компонентами или службами, не связанными между собой напрямую; 2) посредник; 3) делегирование; 4) управление потоком объектов; 5) операция над найденным сообщением."},{
 q: "Шаблон \"Устойчивый к изменениям\" (Protected Variations):",
 a: "*1) для распределения обязанностей между объектами, подсистемами и системами так, чтобы вариации или нестабильность их элементов не оказывали отрицательного влияния на другие элементы, необходимо идентифицировать конкретные нестабильные точки, а обязанности распределить так, чтобы вокруг этих точек был создан (стабильный) интерфейс; 2) посредник; 3) мост; 4) адаптер; 5) неизменяемый объект."},{
 q: "Шаблон \"Ленивая Инициализация\" (Lazy Initialization):",
 a: "*1) использует специальный маркер, чтобы пометить поле, как не загруженное; 2) при каждом обращении к полю оно загружается; 3) статический элемент данных класса; 4) использование счетчика ссылок; 5) конструирование божественного объекта."},{
 q: "Шаблон \"Виртуальный заместитель\" (Virtual Proxy):",
 a: "*1) объект с таким же интерфейсом, как и настоящий объект; 2) при первом обращении к методу объекта загружаются все его данные; 3) призрак; 4) шаблон делегирования; 5) реализует использование функтора."},{
 q: "Контейнер значения (Value Holder):",
 a: "*1) объект с методом getValue, который вызывается для получения  реального  объекта; 2) призрак; 3) функтор; 4) божественный  объект; 5) найденное сообщение."},{
 q: "Шаблон \"Призрак\" (Ghost):",
 a: "*1) объект без каких-либо данных; *2) объект, при первом обращении к которому загружаются  сразу все данные; 3) отделенный интерфейс; 4) ленивый класс; 5) абстрактный класс."},{
 q: "Шаблоны интеграции по типу обмена данными:", 
 a: "*1) файловый обмен; *2) общая база данных; *3) удаленный вызов процедур; *4) обмен сообщениями; 5) общая разделяемая память."},{
 q: "Шаблон делегирования (Delegation pattern):",
 a: "*1) объект внешне выражает некоторое поведение, но реально передаёт ответственность за выполнение этого поведения связанному объекту; *2) обращается по указателю либо ссылке к операции связанного объекта; 3) реализует использование функтора; 4) передает запрос на обслуживание; 5) использует команду."},{
 q: "Что гарантирует, что каждый модуль компьютерной программы имеет только одну обязанность и исполняет её с минимумом побочных эффектов на другие части программы?",
 a: "*1) шаблон функционального проекта (Functional design); 2) полиморфизм; 3) наследование; 4) шаблон делегирования; 5) тестирование."},{
 q: "Шаблон \"Неизменяемый интерфейс\" (Immutable interface):",
 a: "*1) создание неизменяемого объекта; 2) одиночка; 3) ленивый класс; 4) зона дружбы; 5) порт приема сообщений."},{
 q: "Шаблон \"Интерфейс\" (Interface):",
 a: "*1) общий метод для структурирования компьютерных программ для того, чтобы их было проще понять; 2) открытые операции класса; 3) ленивый класс; 4) зона дружбы; 5) порт приема сообщений."},{
 q: "Шаблон \"Интерфейс-маркер\" (Marker interface):",
 a: " *1) в качестве атрибута объекта применяется наличие или отсутствие реализации интерфейса-маркера; *2) альтернатива атрибута  или аннотации в современных языках программирования;  3) реализует динамическую классификацию; 4) идентификатор функтора; 5) ненужная сложность."},{
 q: "Шаблон \"Контейнер свойств\" (Property container):",
 a: "*1) позволяет добавлять дополнительные свойства для класса вместо расширения класса новыми свойствами; 2) реализует множественную классификацию; 3) реализует динамическую классификацию; 4) альтернатива построения иерархии классов; 5) ненужная сложность."},{
 q: "Шаблон \"Канал событий\" (Event channel):",
 a: "*1) расширяет шаблон Наблюдатель (Observer), создавая централизованный канал для событий; *2) использует объекты-представители для подписки и для публикации события в канале; *3) представитель существует отдельно от реального издателя или подписчика; *4) подписчик может получать опубликованные события от более, чем одного объекта, даже если он зарегистрирован только на одном канале; 5) фасад контроллера запросов."},{
 q: "Шаблон \"Отложенная инициализация\" (Lazy initialization):",
 a: "*1) объект, инициализируемый во время первого обращения к нему; *2) ленивая инициализация; 3) наследуемая операция; 4) виртуальная операция; 5) деятельность конструктора помещающего вида."},{
 q: "Шаблон \"Наблюдатель\" (Observer):",
 a: "*1) определяет зависимость \"один ко многим\" между объектами так, что когда один объект меняет своё состояние, все зависимые объекты оповещаются и обновляются автоматически; 2) реализует ловушку исключений; 3) является интерфейсом приема сообщений; 4) реализует фасад системы; 5) реализует обнаружение найденных сообщений."},{
  q: "Шаблон \"Команда\" (Command):",
 a: " *1) инкапсулирует запрос в виде объекта, позволяя передавать их клиентам в качестве параметров, ставить в очередь, протоколировать,  а также поддерживать отмену операций; 2) реализует обработку сообщений; 3) отображает  распределение обязанностей на объекты; 4) реализует сценарий поведения; 5) реализует делегирование обязанностей."},{
 q: "Шаблон \"Состояние\" (State):",
 a: " *1) позволяет объекту изменять своё поведение в зависимости от внутреннего состояния; 2) инкапсулирует содержимое памяти хранителя объектов; 3) отображает ход реализации диаграммы активности; 4) реализует хранитель; 5) реализует диаграммы состояний."},{
 q: "Шаблон \"Интерпретатор\" (Interpreter):",
 a: " *1) получая формальный язык, определяет представление его грамматики и интерпретатор, использующий это представление для обработки выражений языка; 2) реализует адаптер спецификации системы или процесса; 3) играет роль посредника; 4) является абстракцией одного из видов трансляторов;  5) реализует обработку найденных сообщений."},{
 q: "Шаблон \"Стратегия\" (Strategy):",
 a: " *1) определяет группу алгоритмов, инкапсулирует их и делает взаимозаменяемыми; *2) позволяет изменять алгоритм обслуживания независимо от клиентов, его использующих; 3) является синонимом понятия функтор; 4) используется в качестве фасада контроллера запросов; 5) реализует делегирование обязанностей."},{
 q: "Шаблон \"Итератор\" (Iterator):",
 a: " *1) предоставляет способ последовательного доступа к элементам множества, независимо от его внутреннего устройства; 2) реализует операцию цикла; 3) обеспечивает поиск объекта - исполнителя обязанности; 4) реализует отображение активной записи; 5) представляет стратегии поиска объектов."},{
 q: "Шаблон \"Шаблонный метод\" (Template method):",
 a: "*1) определяет алгоритм, некоторые этапы которого делегируются подклассам; 2) позволяет подклассам переопределить этапы алгоритма, не меняя его структуру; *3) является примером анти-шаблона; 4) реализует адаптер стратегии; 5) является альтернативой полиморфизма."},{
 q: "Шаблон \"Посредник\" (Mediator):",
 a: "*1) определяет объект, инкапсулирующий способ взаимодействия объектов; 2) обеспечивает слабую связь, избавляя объекты от необходимости прямо ссылаться друг на друга и даёт возможность независимо изменять их взаимодействие; 3) реализует фасад системы; 4) реализует слабое зацепление объектов; 5) обеспечивает построение наблюдателя."},{
 q: "Шаблон \"Посетитель\" (Visitor):",
 a: "*1) представляет собой операцию, которая будет выполнена над объектами группы классов; 2) даёт возможность определить новую операцию без изменения кода классов, над которыми проводится эта операция; 3) представляет получаемое системой сообщение; 4) является альтернативой полиморфизму; 5) является частным случаем стратегии."},{
 q: "Шаблон \"Адаптер\" (Adapter):",
 a: "*1) конвертирует интерфейс класса в другой интерфейс, ожидаемый клиентом; 2) позволяет классам с разными интерфейсами работать вместе; 3) реализует отношение агрегации между объектами; 4) является альтернативой полиморфизму; 5) является частным случаем моста."},{
 q: "Шаблон \"Заместитель\" (Proxy):",
 a: "*1) предоставляет замену другого объекта для контроля доступа к нему; 2) реализует адаптер или интерфейс; 3) обеспечивает асинхронную передачу сообщений; 4) позволяет строить коллекции исполнителей для цепочек обязанностей; 5) реализует расщепление потоков управления."},{
 q: "Шаблон \"Мост\" (Bridge):",
 a: "*1) разделяет абстракцию и реализацию так, чтобы они могли изменяться независимо; 2) отражает канал передачи сообщений; 3) реализует адаптер; 4) реализует интерфейс; 5) реализует динамическую классификацию."},{
 q: "Шаблон \"Абстрактная фабрика\" (Abstract factory):",
 a: "*1) предоставляет интерфейс для создания групп связанных или зависимых объектов, не указывая их конкретный класс; 2) реализация виртуального конструктора; 3) модуль централизованного создания объектов; 4) является посредником пула объектов; 5) ненужная сложность."},{
 q: "Шаблон \"Компоновщик\" (Composite):",
 a: "*1) компонует объекты в древовидную структуру, представляя их в виде иерархии; 2) позволяет клиенту одинаково обращаться как к отдельному объекту, так и к целому поддереву; 3) модуль связывания объектов; 4) является другом класса итератора коллекций объектов; 5) используется для реализации центрального буфера диаграмм деятельности."},{
 q: "Шаблон \"Строитель\" (Builder):",
 a: "*1) разделяет создание сложного объекта и инициализацию его состояния так, что одинаковый процесс построения может создать объекты с разным состоянием; 2) модуль конструирования сложных объектов; 3) модуль связывания объектов;  4) модуль обслуживания иерархического посетителя; 5) представляет точки расширения диаграмм прецедентов."},{
 q: "Шаблон \"Декоратор\" (Decorator):",
 a: "*1) динамически предоставляет объекту дополнительные возможности; *2) представляет гибкую альтернативу наследованию для расширения функциональности; 3) адаптер фасадов; 4) является альтернативой полиморфизму; 5) является частным случаем стратегии."},{
 q: "Шаблон \"Фабричный метод\" (Factory method):",
 a: "*1) определяет интерфейс для создания объекта, но позволяет подклассам решать, какой класс инстанцировать; *2) позволяет делегировать создание объекта подклассам; 3) представляет операции функтора; 4) является альтернативой полиморфизму; 5) является частным случаем стратегии."},{
 q: "Шаблон \"Фасад\" (Facade):",
 a: "*1) предоставляет единый интерфейс к группе интерфейсов подсистемы; 2) определяет высокоуровневый интерфейс, делая подсистему проще для использования; 3) представляет параметры конструктора класса; 4) является адаптером для иерархического посетителя; 5) используется для классификации найденных сообщений."},{
 q: "Шаблон \"Прототип\" (Prototype):",
 a: " 1) определяет несколько видов объектов, чтобы при создании использовать объект-прототип; *2) создаёт новые объекты, копируя прототип; 3) является реализацией шаблона с параметрами по умолчанию; 4) представляет операцию присваивания фабричным методом; 5) переопределяет операции создания объекта."},{
 q: "Шаблон \"Приспособленец\" (Flyweight):",
 a: "*1) благодаря совместному использованию, поддерживает эффективную работу с большим количеством объектов; 2) является адаптером классов составных объектов; 3) отображает способ виртуализации вычислительных ресурсов; 4) решает задачу оптимизации взаимодействия объектов; 5) представляет точки расширения диаграмм прецедентов."},{
 q: "Шаблон \"Одиночка\" (Singleton):",
 a: "*1) гарантирует, что класс допускает только один экземпляр объекта и предоставляет глобальную точку доступа к нему; 2) класс с запретом объявления массива объектов; 3) класс с единственным конструктором; 4) класс с запретом  передачи сообщений; 5) класс с пустым деструктором."},{
 q: "Методы эффективной реализации стратегии как шаблона: ",
 a: "*1) шаблонно-шаблонные параметры; 2) шаблон делегирования; 3) использование макросредств; 4) использование операторов switch; 5) использование вложенных условных операторов."},{
 q: "Базовый шаблон системы обработки найденных сообщений:",
 a: "*1) наблюдатель; 2) объектный пул; 3) посетитель; 4) объектная клоака; 5) реестр."},{
 q: "Базовый шаблон системы обработки реплик асинхронных сообщений:",
 a: " 1) наблюдатель; 2) объектный пул; *3) посетитель; 4) объектная клоака; 5) реестр."},{
 q: "Базовый шаблон модуля пессимистической блокировки:",
 a: " 1) одиночка; *2) состояние; 3) посетитель; 4) реестр; 5) итератор."},{
 q: "Базовый шаблон модуля оптимистической блокировки:",
 a: "1) одиночка; 2) состояние; *3) посетитель; 4) реестр; 5) итератор."},{
 q: "Базовый шаблон быстрореактивного сервера:",
 a: "*1) объектный пул; 2) состояние; 3) хранитель; 4) иерархический посетитель; 5) цепочка обязанностей."},{   q: "Способы обеспечения гибкости проекта:",
 a: " 1) дата-центрический подход; 2) функционально-центрический подход; *3) объектно-центрический подход; 4) использование единой строгой формальной концептуальной модели; 5) использование стандартов проектирования."},{  q: "Какой из методов отображения иерархии классов в базе данных оптимален по быстродействию?",
 a: "*1) наследование с одной таблицей; 2) наследование с таблицами для каждого класса; 3) наследование с таблицами для каждого конкретного класса; 4) сериализация; 5) внедренные значения."},{
 q: "Как динамически изменить набор свойств объекта класса?",
 a: "*1) помещать свойства в контейнер внутри класса; 2) расширить класс новыми свойствами посредством шаблона класса; 3) определить производный класс; 4) использовать агрегирование; 5) определить ленивый производный класс."},{
 q: "Какой из методов отображения иерархии классов в базе данных оптимален по памяти?",
 a: " 1) наследование с одной таблицей; 2) наследование с таблицами для каждого класса; *3) наследование с таблицами для каждого конкретного класса; 4) использовать агрегирование; 5) использование компоновщика отображений наследования."},{
 q: "Шаблон \"Активная запись\" (Active Record):",
 a: "*1) объект, выполняющий роль оболочки для строки таблицы или представления базы данных; *2) инкапсулирует доступ к базе данных; *3) добавляет к данным логику домена; 4) указывает текущую позицию в таблице; 5) характеризует связь с базой данных."},{
 q: "Шаблон \"Блокировка с низкой степенью детализации\" (Coarse-Grained Lock):",
 a: "*1) блокирует группу взаимосвязанных объектов как единый элемент; 2) приостанавливает выполнение потока; 3) организует ожидание реплики ответа на сообщение; 4) организует ожидание запрашиваемого ресурса; 5) организует ожидание выхода из критической секции."},{
 q: "Шаблон \"Внедренное значение\" (Embedded Value):",
 a: "*1) отображает объект на несколько полей таблицы; 2) соответствуют другому объекту; 3) фиксирует принятое сообщение; 4) представляет неизменяемый объект; 5) сохраняет сложный объект в одном поле."},{
 q: "Шаблон \"Двухэтапное представление\" (Two Step View):",
 a: "1) выполняет визуализацию данных домена;*2) вначале формирует  некое подобие логической страницы, после чего преобразует логическую страницу в формат HTML; 3) реализует адаптер; 4) обеспечивает мобильность приложения; 5) обеспечивает реализацию полиморфизма."},{
 q: "Что связывает классы во время настройки, а не во время компиляции приложения?",
 a: "*1) дополнительный модуль (Plugin);  2) двухэтапное представление; 3) адаптер; 4) мост; 5) посредник."},{
 q: "Шаблон \"Единица работы\" (Unit of Work):",
 a: "*1) содержит список объектов, охватываемых транзакцией; 2) координирует запись изменений в базу данных; 3) разрешает проблемы параллелизма; 3) реализует сценарий; 4) представяет обязанность объекта; 5) представляет команду."},{
 q: "Шаблон \"Загрузка по требованию\" (Lazy Load):",
 a: "*1) объект, который не содержит все требующиеся данные; *2) объект, который может загрузить свои данные в случае необходимости; 3) операция ленивого класса; 4) прием сообщения; 5) получение уведомления о событии."},{
 q: "Шаблон \"Интерфейс удаленного доступа\" (Remote Facade):",
 a:"*1) предоставляет интерфейс с низкой степенью детализации для доступа к объектам, имеющим интерфейс с высокой степенью детализации; 2) повышает эффективность работы в сети; 3) порт приема-передачи сообщений; 4) фасад контроллера запросов; 5) базовый класс шаблона удаленного вызова процедур."},{
 q: "Что гарантирует, что каждый объект будет загружен из базы данных только один раз, сохраняя загруженные данные в специальной коллекции?",
 a: "*1) коллекция объектов (Identity Map); 2) блокировка; 3) одиночка; 4) однопоточное выполнение; 5) модель предметной области."},{
 q: "Шаблон \"Контроллер запросов\" (Front Controller):",
 a: "*1) обрабатывает все запросы к Web-сайту; 2) планировщик; 3) порт приема-передачи сообщений; 4) фасад системы; 5) базовый класс шаблона удаленного вызова процедур."},{
 q: "Шаблон \"Контроллер приложения\" (Application Controller):",
 a: "*1) точка централизованного управления порядком отображения интерфейсных экранов и потоком функций приложения; 2) планировщик; 3) порт приема-передачи сообщений; 4) фасад системы; 5) базовый класс шаблона удаленного вызова процедур."},{
 q: "Шаблон \"Контроллер страниц\" (Page Controller):",
 a: " 1) обрабатывает запрос к конкретной Web-странице: 2) выполняет конкретное действие на Web-сайте; 3) планировщик; *4)порт приема-передачи сообщений; *5) фасад системы."},{
 q: "Что представляет табличные данные из базы данных в оперативной памяти:",
 a: "*1) множество записей (Record Set); 2) коллекция; 3) объектный пул; 4) цепочка обязанностей; 5) комок грязи."},{
 q: "Шаблон \"Модель - представление - контроллер\" (Model View Controller):",
 a: "*1) распределяет обработку взаимодействия с пользовательским интерфейсом между тремя участниками; 2) отражает логику обработки всех сообщений; 3) отражает объектную модель домена; 4) представляет структуру системы; 5) является примером инверсии абстракции."},{
 q: "Шаблон \"Модель предметной области\" (Domain Model):",
 a: "*1) объектная модель домена, охватывающая поведение (функции) и свойства (данные); 2) отражает логику обработки всех сообщений; 3) отражает объектную модель домена; 4) представляет структуру системы; 5) является примером инверсии абстракции."},{
 q: "Шаблон \"Модуль таблицы\" (Table Module):",
 a: "*1) охватывает логику обработки всех записей хранимой или виртуальной таблицы базы данных; 2) порт приема запросов к таблице; 3) одиночка; 4) коллекция; 5) объектный пул."},{
 q: "Как представить иерархию наследования классов в виде одной таблицы, столбцы которой соответствуют всем полям классов, входящих в иерархию?",
 a: "*1) наследование с одной таблицей (Single Table Inheritance); 2) наследование с таблицами для каждого класса (Class Table Inheritance); 3) наследование с таблицами для каждого конкретного класса (Concrete Table Inheritance); 4) отображение с помощью таблицы ассоциаций; 5) отображение зависимых объектов."},{
 q: "Как представить иерархию наследования классов, используя по одной таблице для каждого класса?",
 a: "*1) наследование с таблицами для каждого класса (Class Table Inheritance); 2) наследование с одной таблицей (Single Table Inheritance); 3) наследование с таблицами для каждого конкретного класса (Concrete Table Inheritance); 4) отображение с помощью таблицы ассоциаций; 5) отображение зависимых объектов."},{
 q: "Как представить иерархию наследования классов, используя по одной таблице для каждого конкретного класса этой иерархии?",
 a: "*1) наследование с таблицами для каждого конкретного класса (Concrete Table Inheritance); 2) наследование с одной таблицей (Single Table Inheritance); 3) наследование с таблицами для каждого класса (Class Table Inheritance); 4) отображение с помощью таблицы ассоциаций; 5) отображение зависимых объектов."},{
 q: "Шаблон \"Неявная блокировка\" (Implicit Lock):",
 a: "1) предоставляет инфраструктуре приложения или супертипу слоя право накладывать автономные блокировки; *2) гарантирует выполнение всех необходимых действий по наложению и снятию блокировки; 3) таинственный код; 4) ненужная сложность; 5) инверсия абстракции."},{
 q: "Шаблон \"Объект - значение\" (Value Object):",
 a: "*1) небольшие простые объекты наподобие денежных значений или диапазонов дат; *2) объекты, равенство которых не основано на равенстве идентификаторов; 3) божественный объект; 4) призрак; 5) экземпляр класса данных."},{ 
 q: "Шаблон \"Объект запроса\" (Query Object):",
 a: "*1) объект, представляющий запрос к базе данных; 2) экземпляр команды; 3) божественный объект; 4) призрак; 5) экземпляр класса данных."},{
 q: "Что применяется для переноса данных между процессами в целях уменьшения количества вызовов?",
 a: "*1) объект переноса данных (Data Transfer Object); 2) экземпляр команды; 3) божественный объект; 4) призрак; 5) экземпляр класса данных."},{
 q: "Что предотвращает возникновение конфликтов между параллельными транзакциями путем обнаружения конфликта и отката транзакции?",
 a: "*1) оптимистическая автономная блокировка (Optimistic Offline Lock); 2) блокировка; 3) критическая секция; 4) планировщик; 5) протокольный конечный автомат."},{
 q: "Шаблон \"Отделенный интерфейс\" (Separated Interface):",
 a: "*1) предполагает размещение интерфейса и его реализации в разных пакетах; 2) уменьшает зацепление подсистем; 3) сохраняет сильную связность системы; 4) ненужная сложность; 5) два туннеля."},{
 q: "Что отображает ассоциации между объектами на ссылки внешнего ключа между таблицами базы данных?",
 a: "*1) отображение внешних ключей (Foreign Key Mapping); 2) ненужная сложность; 3) внедренное значение; 4) поле идентификации; 5) божественный объект."},{
 q: "Как передать некоторому классу полномочия по выполнению отображения для дочернего класса?",
 a: "*1) отображение зависимых объектов (Dependent Mapping); 2) удаленный вызов процедур; 3) делегирование; 4) приватизация; 5) отделенный интерфейс."},{
 q: "Что хранит описание деталей объектно-реляционного отображения в виде метаданных?",
 a: "*1) отображение метаданных (MetadataMapping); 2) отделенный интерфейс; 3) таблица данных; 4) сериализованный объект; 5) ненужная сложность."},{ 
 q: "Что сохраняет множество ассоциаций в виде таблицы, содержащей внешние ключи таблиц, связанных ассоциациями?",
 a: "*1) отображение с помощью таблицы ассоциаций (Association Table Mapping); 2) таблица данных; 3) коллекция; 4) сериализованный объект; 5) божественный объект."},{
 q: "Шаблон \"Пессимистическая автономная блокировка\" (Pessimistic Offline Lock):",
 a: "1) предотвращает возникновение конфликтов между параллельными транзакциями; *2) предоставляет доступ к данным в конкретный момент времени только одной транзакции; 3) использует однопоточное выполнение; 4) кодирование путём исключения; 5) самоуничтожение."},{
 q: "Что сохраняет идентификатор записи базы данных для поддержки соответствия между объектом приложения и строкой базы данных?",
 a: "*1) поле идентификации (Identity Field); 2) внедренное значение; 3) призрак; 4) посредник; 5) шлюз записи."},{
 q: "Шаблон \"Представление по шаблону\" (Template View):",
 a: "*1) преобразует результаты выполнения запроса в формат HTML путем внедрения маркеров в HTML-страницу; 2) адаптер; 3) декоратор; 4) фасад; 5) использует завистливые функции."},{
 q: "Шаблон \"Представление с преобразованием\" (Transform View):",
 a: "*1) представление, которое поочередно обрабатывает элементы данных домена и преобразует их в код HTML; 2) адаптер; 3) декоратор; 4) фасад; 5) использует завистливые функции."},{
 q: "Шаблон \"Преобразователи наследования\" (Inheritance Mappers):",
 a: "*1) структура, предназначенная для организации преобразователей, которые работают с иерархиями наследования; 2) отображение с помощью таблицы ассоциаций; 3) работает в зоне дружбы; 4) используют динамическую классификацию; 5) аналог лодочного якоря."},{
 q: "Шаблон \"Преобразователь\" (Mapper):",
 a: "*1) объект, устанавливающий взаимодействие между двумя независимыми объектами; 2) отображение с помощью таблицы ассоциаций; 3) работает в зоне дружбы; 4) используют динамическую классификацию; 5) аналог лодочного якоря."},{
 q: "Шаблон \"Преобразователь данных\" (Data Mapper):",
 a: "*1) слой преобразователей (Mapper), который осуществляет передачу данных между объектами и базой данных; 2) сохраняет преобразуемые данные независимыми друг от друга и от самого преобразователя; 3) отображение с помощью таблицы ассоциаций; 4) работает в зоне дружбы; 5) ненужная сложность."},{
 q: "Шаблон \"Реестр\" (Registry):",
 a: "*1) глобальный объект, который используется другими объектами для поиска общих объектов или служб; 2) коллекция; 3) одиночка; 4) божественный объект; 5) объектная клоака."},{
 q: "Шаблон \"Сериализованный крупный объект\" (Serialized LOB):",
 a: "*1) сохраняет граф объектов путем их сериализации в единый крупный объект (Large Object, LOB) и помещает его в поле базы данных; 2) объектная клоака; 3) призрак; 4) используется в зоне дружбы; 5) божественный объект."},{
 q: "Шаблон \"Слой служб\" (Service Layer):",
 a: "*1) схема определения границ приложения посредством слоя служб, который устанавливает множество доступных действий; 2) координирует отклик приложения на каждое действие; 3) представляет фасад; 4) играет роль декоратора; 5) раздувает интерфейс."},{
 q: "Шаблон \"Сохранение состояния сеанса в базе данных\" (Database Session State):",
 a: "*1) сохраняет состояние сеанса как обычное содержимое базы данных; 2) выполняет посредник; 3) операция ленивого класса; 4) ненужная сложность; 5) функция для галочки."},{
 q: "Шаблон \"Сохранение состояния сеанса на стороне клиента\" (Client Session State):",
 a: "*1) сохраняет состояние сеанса на стороне клиента; 2) реализует призрак; 3) выполняет посредник; 4) операция ленивого класса; 5) функция для галочки."},{
 q: "Шаблон \"Сохранение состояния сеанса на стороне сервера\" (Server Session State):",
 a: "*1) сохраняет сериализованное представление состояния сеанса на стороне сервера; 2) реализует призрак; 3) выполняет посредник; 4) операция ленивого класса; 5) функция для галочки."},{
 q: "Шаблон \"Супертип слоя\" (Layer Supertype):",
 a: "*1) тип, выполняющий роль суперкласса для всех классов своего слоя; 2) представляет коллекцию интерфейсов; 3) определяет порты обмена; 4) определяет порты управления; 5) является фасадом системы."},{
 q: "Шаблон \"Сценарий транзакции\" (Transaction Script):",
 a: "*1) способ организации бизнес-логики по процедурам, каждая из которых обслуживает один запрос, инициируемый слоем представления; 2) использует однопоточное выполнение; 3) коллекция команд; 4) коллекция функторов; 5) реализация диаграммы деятельности."},{
 q: "Что устраняет зависимость приложения от труднодоступных или проблемных служб на время тестирования?",
 a: "*1) фиктивная служба (Service Stub); 2) отделенный интерфейс; 3) однопоточное выполнение; 4) внедренное значение; 5) кодирование путём исключения."},{
 q: "Шаблон \"Хранилище\" (Repository):",
 a: "*1) выступает в роли посредника между слоем домена и слоем отображения данных; *2) предоставляет интерфейс в виде коллекции для доступа к объектам домена; 3) коллекция; 4) объектная клоака; 5) божественный объект."},{
 q: "Шаблон \"Частный случай\" (Special Case):",
 a: "*1) производный класс, описывающий поведение объекта в особых ситуациях; 2) внедренное значение; 3) кодирование путём исключения; 4) самоуничтожение; 5) функции для галочки."},{
 q: "Шаблон \"Шлюз\" (Gateway):",
 a: "*1) объект, инкапсулирующий доступ к внешней системе или источнику данных; 2) порт делегирования; 3) порт управления; 4) прослушиватель событий;  5) интерфейс моста."},{
 q: "Шаблон \"Шлюз записи данных\" (Row Data Gateway):",
 a: "*1) объект, выполняющий роль шлюза (Gateway) к отдельной записи источника данных; *2) каждой строке таблицы базы данных соответствует свой экземпляр шлюза записи данных (Row Data Gateway); 3) фасад доступа к записи таблицы; 4) порт доступа к записи таблицы; 5) посредник."},{
 q: "Шаблон \"Шлюз таблицы данных\" (Table Data Gateway):",
 a: "*1) объект, выполняющий роль шлюза (Gateway) к базе данных; 2) коллекция; 3) фасад доступа к таблице; 4) порт доступа к таблице; 5) посредник."}
];

function doMix(arr) {
 let n=arr.length;
 for (let i=0; i<n; i++) {
  let j0=getRnd(n), j1=getRnd(n);
  if (j0!=j1) {
   let x=arr[j1];
   arr[j1]=arr[j0];
   arr[j0]=x;
  }
 }
}

doMix(arrObjects);

var element = document.getElementById("myForm");
var i_start=0, i_stop=arrObjects.length;
var timerid=0, ggg=0, attempt=0, result=0;
var xlp=[];
var xlm=[];
var xlr=[];
 
getNext();

function getNext() {
 ggg=1;
 attempt=0, result=0;
 if (timerid) clearTimeout(timerid); 
 timerid=setTimeout(test1Function, 1000*(delay+1)*i_delta);
 document.getElementById("test_nmb").innerHTML=Math.floor(i_start/i_delta)+1
 for (let i=0; i<i_delta; i++) {
  if (i_start>=i_stop) i_start=0;
  ansqst(i_start,i);
  i_start++;
 }
}
 
function getRnd(n) {
 return Math.floor(Math.random() * n);
}

function ansqst(i,iq) { 
 var tag = document.createElement("div");
 tag.id='d'+i;
 element.appendChild(tag);
 tag.innerHTML='<p id=>'+i+' ?'; 
 if (arrObjects[i].a==undefined) return;
 tag.innerHTML='<p id=>'+i+' ??'; 
 if (arrObjects[i].q==undefined) return;
 let h='<p id="q'+i+'"><b>'+(iq+1)+') '+arrObjects[i].q+'</b><br>';
 var tt='abcdefghijklmnopqrstxuz';
 var ss=arrObjects[i].a.split(";");
 var xx=[];
 for (let kk=0; kk<ss.length; kk++) {
  let y=tt.substr(getRnd(tt.length),1);
  var s=ss[kk]; 
  let j=s.indexOf(") ");
  if (j<0) break;
  if (s.substr(0,j-1).indexOf('*')>=0) y='v';
  var z=i+'_'+kk+y;
  var x = '<br>&nbsp;&nbsp;&nbsp;&nbsp;<label><input type = "checkbox" name = "t'+z+'">'; 
  j+=2;
  let k=s.substr(j).indexOf(';');
  if (k<0) k=s.substr(j).indexOf('.');
  y=(k>=0)? s.substr(j,k):s.substr(j); 
  xx[kk]=x+'<span id="s'+z+'">'+y+'</span>';
 }
 doMix(xx);
 let n=xx.length, m=n-1;
 for (let j=0; j<n; j++) {
  h+=xx[j]+((j<m)? ';' : '.')+'</label>';
 }
 h+='<hr>';
 tag.innerHTML=h; 
}

function test0Function() {
 testFunction(0);
}

function test1Function() {
 testFunction(1);
}


function testFunction(total) {
  if ((total>0)&&(result==0)) result=1;
  ggg=0;
  if (timerid) clearTimeout(timerid); 
  timerid=0;
  let form=document.getElementById('myForm');
  let divs=form.getElementsByTagName('div');
  let n=divs.length, lp=0, lm=0;
  for (let i=0; i<n; i++) {
   let div=divs[i]; 
   let inps=div.getElementsByTagName('input');
   let m=inps.length;
   let str=div.id;
   let suf=str.substr(1);
   let k=0, op=0, ep=0, om=0, em=0;
   for (let j=0; j<m; j++) {
    let elm=inps[j];
    let itm='s'+elm.name.substr(1);
    let lbl=document.getElementById(itm);
    if (elm.checked){
     k++;
    }
    if (elm.name.indexOf('v')>=0) {
     op++;
     if (elm.checked){
      if (total>0) lbl.style.color="green";
      ep++;
     } else {
      if (total>0) lbl.style.color="red";
     }
    } else {
     om++;
     if (elm.checked) em++; 
     if (total>0) lbl.style.color=(elm.checked)? "red":"green";
    }
   }
   if (op>0) lp+=ep/op;
   if (om>0) lm+=em/om;
  }
  xlp[attempt]=rrr(lp,n);
  xlm[attempt]=rrr(lm,n);
  xlr[attempt]=result;
  attempt++;
  
  let dem=document.getElementById("demo");
  
  let x="<p>";
  let i=0;
  for (; (i<attempt)&&(xlr[i]==0); i++) {
   x+="Попытка "+(i+1)+". ";
   x+="Выделено "+xlp[i]+"% правильных и "+xlm[i]+"% неправильных альтернатив ответов";
   x+="<br>";
  }
  if ((i<attempt)&&(xlr[i]>0)) {  
   x+="<mark>Попытка "+(i+1)+". ";
   x+="Выделено "+xlp[i]+"% правильных и "+xlm[i]+"% неправильных альтернатив ответов</mark>";
   x+="<br>";
   i++;
  }
  for (; (i<attempt)&&(xlr[i]>0); i++) {
   x+="<mark>Попытка "+(i+1)+". </mark>";
   x+="<del>Выделено "+xlp[i]+"% правильных и "+xlm[i]+"% неправильных альтернатив ответов</del>";
   x+="<br>";
  }
 
  dem.innerHTML=x;
  
  document.location.href = "#bottom";
}

function rrr(x,n) {
 var y=x/n;
 y*=100;
 return Math.round(y);
}


function nextFunction() {
 let form=document.getElementById('myForm');
 let divs=form.getElementsByTagName('div');
 for (let i=divs.length; i>0; ) {
  let div=divs[--i];
  div.parentNode.removeChild(div);
 }
 let dem=document.getElementById("demo");
 dem.innerHTML="";
 getNext();
 document.location.href = "#topfrm";
} 

</script>
</body>
</html>

