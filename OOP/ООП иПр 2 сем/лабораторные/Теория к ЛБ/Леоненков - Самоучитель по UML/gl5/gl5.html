<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; WINDOWS-1251">
   <meta name="Author" content="Leonenkov">
   <meta name="Generator" content="Aditor">
   <meta name="Description" content="UML Teach Yourself">
   <meta name="Owner" content="lesly@mipk-kspu.kharkov.ua">
   <meta name="Keywords" content="Леоненков, самоучитель UML, UML">

<TITLE> Леоненков. Самоучитель UML.</TITLE>
<!--                                                                   -->
<!-- (C) Owner: Oleg G. Starusev  -->
<!-- (C) НТУ "ХПИ". Каф.Информатики и интеллектуальной собственности, 2003. -->

</HEAD>

<BODY background=../iip_1.jpg>
<p><a href=../index.htm>Каталог</a></p>
<hr>

<p><CENTER><font size="4"><b>ГЛАВА 5 <br> Диаграмма классов (class diagram) </b></font></center>
</P>
<br>
<br>

<ul>
  <li><a href="gl5.html#1">5.1. Класс</a><ul>
  <li><a href="gl5.html#2">Имя класса</a>
  <li><a href="gl5.html#3">Атрибуты класса</a>
  <li><a href="gl5.html#4">Операция</a></ul>
  <li><a href="gl5.html#5">5.2. Отношения между классами</a><ul>
  <li><a href="gl5.html#6">Отношение зависимости</a>
  <li><a href="gl5.html#7">Отношение ассоциации </a>
  <li><a href="gl5.html#8">Отношение агрегации</a>
  <li><a href="gl5.html#9">Отношение композиции</a>
  <li><a href="gl5.html#10">Отношение обобщения</a></ul>
  <li><a href="gl5.html#11">5.3. Интерфейсы</a>
  <li><a href="gl5.html#12">5.4. Объекты</a>
  <li><a href="gl5.html#13">5.5. Шаблоны или параметризованные классы </a>
  <li><a href="gl5.html#14">5.6. Рекомендации по построению диаграмм классов </a>
</UL>


<P>
Центральное место в ООАП занимает разработка логической модели системы в виде диаграммы классов. Нотация классов в языке UML проста и интуитивно понятна всем, кто когда-либо имел опыт работы с CASE-инструментариями. Схожая нотация применяется и для объектов — экземпляров класса, с тем различием, что к имени класса добавляется имя объекта и вся надпись подчеркивается.
</P>
<P>
Нотация UML предоставляет широкие возможности для отображения дополнительной информации (абстрактные операции и классы, стереотипы, общие и частные методы, детализированные интерфейсы, параметризованные классы). При этом возможно использование графических изображений для ассоциаций и их специфических свойств, таких как отношение агрегации, когда составными частями класса могут выступать другие классы.
</P>
<P>
Диаграмма классов (class diagram) служит для представления статической структуры модели системы в терминологии классов объектно-ориентированного программирования. Диаграмма классов может отражать, в частности, различные взаимосвязи между отдельными сущностями предметной области, такими как объекты и подсистемы, а также описывает их внутреннюю структуру и типы отношений. На данной диаграмме не указывается информация о временных аспектах функционирования системы. С этой точки зрения диаграмма классов является дальнейшим развитием концептуальной модели проектируемой системы.
</P>
<P>
Диаграмма классов представляет собой некоторый граф, вершинами которого являются элементы типа &quot;классификатор&quot;, которые связаны различными типами структурных отношений. Следует заметить, что диаграмма классов может также содержать интерфейсы, пакеты, отношения и даже отдельные экземпляры, такие как объекты и связи. Когда говорят о данной диаграмме, имеют в виду статическую структурную модель проектируемой системы. Поэтому диаграмму классов принято считать графическим представленном таких структурных взаимосвязей логической модели системы, которые не зависят или инвариантны от времени.
</P>
<P>
Диаграмма классов состоит из множества элементов, которые в совокупности отражают декларативные знания о предметной области. Эти знания интерпретируются в базовых понятиях языка UML, таких как классы, интерфейсы и отношения между ними и их составляющими компонентами. При этом отдельные компоненты этой диаграммы могут образовывать пакеты для представления более общей модели системы. Если диаграмма классов является частью некоторого пакета, то ее компоненты должны соответствовать элементам этого пакета, включая возможные ссылки на элементы из других пакетов.
</P>
<P>
В общем случае пакет статической структурной модели может быть представлен в виде одной или нескольких диаграмм классов. Декомпозиция некоторого представления на отдельные диаграммы выполняется с целью удобства и графической визуализации структурных взаимосвязей предметной области. При этом компоненты диаграммы соответствуют элементам статической семантической модели. Модель системы, в свою очередь, должна быть согласована с внутренней структурой классов, которая описывается на языке UML.
</P>

<p>&nbsp;
<a NAME="1"></a><font size="4">5.1. Класс</font>

<P>
Класс (class) в языке UML служит для обозначения множества объектов, которые обладают одинаковой структурой, поведением и отношениями с объектами из других классов. Графически класс изображается в виде прямоугольника, который дополнительно может быть разделен горизонтальными линиями на разделы или секции (рис. 5.1). В этих разделах могут указываться имя класса, атрибуты (переменные) и операции (методы).
</P>
<IMG src="gl5-1.jpg">
<P>
<b>
Рис. 5.1.</b> Графическое изображение класса на диаграмме классов
</P>
<P>
Обязательным элементов обозначения класса является его имя. На начальных этапах разработки диаграммы отдельные классы могут обозначаться простым прямоугольником с указанием только имени соответствующего класса (рис. 5.1, а). По
мере проработки отдельных компонентов диаграммы описания классов дополняются атрибутами (рис. 5.1, б) и операциями (рис. 5.1, в).
</P>
<P>
Предполагается, что окончательный вариант диаграммы содержит наиболее полное описание классов, которые состоят из трех разделов или секций. Иногда в обозначениях классов используется дополнительный четвертый раздел, в котором приводится семантическая информация справочного характера или явно указываются исключительные ситуации.
</P>
<P>
Даже если секция атрибутов и операций является пустой, в обозначении класса она выделяется горизонтальной линией, чтобы сразу отличить класс от других элементов языка UML. Примеры графического изображения классов на диаграмме классов приведены на рис. 5.2. В первом случае для класса &quot;Прямоугольник&quot; (рис. 5.2, а) указаны только его атрибуты — точки на координатной плоскости, которые определяют его расположение. Для класса &quot;Окно&quot; (рис. 5.2, б) указаны только его операции, секция атрибутов оставлена пустой. Для класса &quot;Счет&quot; (рис. 5.2, в) дополнительно изображена четвертая секция, в которой указано исключение — отказ от обработки просроченной кредитной карточки.
</P>
<IMG src="gl5-2.jpg">
<P>
<b>
Рис.5.2.</b> Примеры графического изображения классов на диаграмме
</P>
<p>&nbsp;
<a NAME="2"></a><font size="4">
Имя класса</font>
</P>
<P>
Имя класса должно быть уникальным в пределах пакета, который описывается некоторой совокупностью диаграмм классов (возможно, одной диаграммой). Оно указывается в первой верхней секции прямоугольника. В дополнение к общему правилу наименования элементов языка UML, имя класса записывается по центру секции имени полужирным шрифтом и должно начинаться с заглавной буквы. Рекомендуется в качестве имен классов использовать существительные, записанные по практическим соображениям без пробелов. Необходимо помнить, что именно имена классов образуют словарь предметной области при ООАП.
</P>
<P>
В первой секции обозначения класса могут находиться ссылки на стандартные шаблоны или абстрактные классы, от которых образован данный класс и, соответственно, от которых он наследует свойства и методы. В этой секции может приводиться информация о разработчике данного класса и статус состояния разработки, а также могут записываться и другие общие свойства этого класса, имеющие отношение к другим классам диаграммы или стандартным элементам языка UML.
</P>
<P>
Примерами имен классов могут быть такие существительные, как &quot;Сотрудник&quot;, &quot;Компания&quot;, &quot;Руководитель&quot;, &quot;Клиент&quot;, &quot;Продавец&quot;, &quot;Менеджер&quot;, &quot;Офис&quot; и многие другие, имеющие непосредственное отношение к моделируемой предметной области и функциональному назначению проектируемой системы.
</P>
<P>
Класс может не иметь экземпляров или объектов. В этом случае он называется абстрактным классом, а для обозначения его имени используется наклонный шрифт (курсив). В языке UML принято общее соглашение о том, что любой текст, относящийся к абстрактному элементу, записывается курсивом. Данное обстоятельство является семантическим аспектом описания соответствующих элементов языка UML.
</P>
<P>
<U><b><font color="#006600">Примечание</font></b></U>
</P>
<P>
<font color="#006600">В некоторых случаях необходимо
явно указать, к какому пакету относится тот
или иной класс. Для этой цели используется
специальный символ разделитель — двойное
двоеточие &quot;::&quot;. Синтаксис строки имени
класса в этом случае будет следующий &lt;Имя_пакета&gt;::&lt;Имя_класса&gt;.
Другими словами, перед именем класса должно
быть явно указано имя пакета, к которому его
следует отнести. Например, если определен
пакет с именем &quot;Банк&quot;, то класс &quot;Счет&quot;
в этом банке может быть записан в виде: &quot;Банк::Счет&quot;.</font>
</P>
<p>&nbsp;
<a NAME="3"></a><font size="4">
Атрибуты класса</font>
</P>
<P>
Во второй сверху секции прямоугольника класса записываются его атрибуты (attributes) или свойства. В языке UML принята определенная стандартизация записи атрибутов класса, которая подчиняется некоторым синтаксическим правилам. Каждому атрибуту класса соответствует отдельная строка текста, которая состоит из квантора видимости атрибута, имени атрибута, его кратности, типа значений атрибута и, возможно, его исходного значения:
</P>
<P>
&lt;квантор видимости&gt;&lt;имя атрибута&gt;[кратность]:
</P>
<P>
&lt;тип атрибута&gt; = &lt;исходное значение&gt;{строка-свойство}
</P>
<P>
Квантор видимости может принимать одно из трех возможных значений и, соответственно, отображается при помощи специальных символов:
</P>
<ul>
  <li>Символ &quot;+&quot; обозначает атрибут с областью видимости типа общедоступный (public). Атрибут с этой областью видимости доступен или виден из любого другого класса пакета, в котором определена диаграмма.</li>
  <li>Символ &quot;#&quot; обозначает атрибут с областью видимости типа защищенный (protected). Атрибут с этой областью видимости недоступен или невиден для всех классов, за исключением подклассов данного класса.</li>
  <li>И, наконец, знак &quot;-&quot; обозначает атрибут с областью видимости типа закрытый (private). Атрибут с этой областью видимости недоступен или невиден для всех классов без исключения.</li>
</ul>
<P>
Квантор видимости может быть опущен. В этом случае его отсутствие просто означает, что видимость атрибута не указывается. Эта ситуация отличается от принятых по умолчанию соглашений в традиционных языках программирования, когда отсутствие квантора видимости трактуется как public или private. Однако вместо условных графических обозначений можно записывать соответствующее ключевое слово:
public, protected, private.
</P>
<p><u><b><font color="#006600">Примечание</font></b></u></p>
<P>
<font color="#006600">Поскольку язык UML инвариантен
относительно реализации своих конструкций
в конкретных языках программирования,
семантика отдельных кванторов видимости не
является строго фиксированной. Значения
этих кванторов должны дополнительно
уточняться пояснительным текстом на
естественном языке или соглашением по
использованию соответствующих программно-зависимых
синтаксических конструкций.</font>
</P>
<P>
Имя атрибута представляет собой строку текста, которая используется в качестве идентификатора соответствующего атрибута и поэтому должна быть уникальной в пределах данного класса. Имя атрибута является единственным обязательным элементом синтаксического обозначения атрибута.
</P>
<P>
Кратность атрибута характеризует общее количество конкретных атрибутов данного типа, входящих в состав отдельного класса. В общем случае кратность записывается в форме строки текста в квадратных скобках после имени соответствующего атрибута:
</P>
<P><font face="Courier New" size="2">
[нижняя_граница1 .. верхняя_граница1, нижняя_граница2.. верхняя_грашца2, ..., нuжняя_гpaнuцak .. верхняя_границаk],</font>
</P>
<P>
где нижняя_граница и верхняя_граница являются положительными целыми числами, каждая пара которых служит для обозначения отдельного замкнутого интервала целых чисел, у которого нижняя (верхняя) граница равна значению нижняя_граница (верхняя_граница). В целом данное условное обозначение кратности соответствует теоретико-множественному объединению соответствующих интервалов. В качестве верхней_границы может использоваться специальный символ &quot;*&quot;, который означает произвольное положительное целое число. Другими словами, это означает неограниченное сверху значение кратности соответствующего атрибута.
</P>
<P>
Значения кратности из интервала следуют в монотонно возрастающем порядке без пропуска отдельных чисел, лежащих между нижней и верхней границами. При этом придерживаются следующего правила: соответствующие нижние и верхние границы интервалов включаются в значение кратности. Если в качестве кратности указывается единственное число, то кратность атрибута принимается равной данному числу. Если же указывается единственный знак &quot;*&quot;, то это означает, что кратность атрибута может быть произвольным положительным целым числом или нулем.
</P>
<P>
В качестве примера рассмотрим следующие варианты задания кратности атрибутов.
</P>
<ul>
  <li>[0..1] означает, что кратность атрибута может принимать значение О или 1. При этом 0 означает отсутствие значения для данного атрибута.</li>
  <li>[0..*] означает, что кратность атрибута может принимать любое положительное целое значение большее или равное 0. Эта кратность может быть записана короче в виде простого символа —
    [*].</li>
  <li>[1.:*] означает, что кратность атрибута может принимать любое положительное целое значение большее или равное 1.</li>
  <li>[1..5] означает, что кратность атрибута может принимать любое значение из чисел: 1, 2, 3, 4, 5.</li>
  <li>[1..3,5,7] означает, что кратность атрибута может принимать любое значение из чисел: 1, 2, 3, 5, 7.</li>
  <li>[1..3,7.. 10] означает, что кратность атрибута может принимать любое значение из чисел: 1, 2, 3, 7, 8, 9, 10.</li>
  <li>[1..3,7..*] означает, что кратность атрибута может принимать любое значение из чисел: 1, 2, 3, а также любое положительное целое значение большее или равное 7.</li>
</ul>
<P>
Если кратность атрибута не указана, то по умолчанию принимается ее значение равное
1..1, т. е. в точности 1.
</P>
<P>
Тип атрибута представляет собой выражение, семантика которого определяется языком спецификации соответствующей модели. В нотации UML тип атрибута иногда определяется в зависимости от языка программирования, который предполагается использовать для реализации данной модели. В простейшем случае тип атрибута указывается строкой текста, имеющей осмысленное значение в пределах пакета или модели, к которым относится рассматриваемый класс.
</P>
<P>
Можно привести следующие примеры задания имен и типов атрибутов классов:
</P>
<ul>
  <li>цвет: Соlоr — здесь цвет является именем атрибута, Color — именем типа данного атрибута. Указанная запись может определять традиционно используемую RGB-модель (красный, зеленый, синий) для представления цвета. В этом случае имя типа Color как раз и характеризует семантическую конструкцию, которая применяется в большинстве языков программирования для представления цвета.</li>
  <li>имя_сотрудника [1..2] : String — здесь имя_сотрудника является именем атрибута, который служит для представления информации об имени, а возможно, и отчестве конкретного сотрудника. Тип атрибута String (Строка) как раз и указывает на тот факт, что отдельное значение имени представляет собой строку текста из одного или двух слов (например, &quot;Кирилл&quot; или &quot;Дмитрий Иванович&quot;). Поскольку во многих языках программирования существует тип данных String, использование соответствующего англоязычного термина не вызывает недоразумения у большинства программистов. Однако, хотя в языке UML все термины даются в англоязычном представлении, использование в качестве типа атрибута
Строка в данной ситуации не исключается и определяется только соображениями удобства.</li>
  <li>видимость:Boolean — здесь видимость есть имя абстрактного атрибута (курсив здесь не случаен), который может характеризовать наличие визуального представления соответствующего класса на экране монитора. В этом случае тип Boolean означает, что возможными значениями данного атрибута является одно из двух логических значений: истина (true) или ложь (false). При этом значение истина может соответствовать наличию графического изображения на экране монитора, а значение ложь — его отсутствию, о чем дополнительно указывается в пояснительном тексте. Поскольку кратность атрибута видимость не указана, она принимает значение 1 по умолчанию. В этой ситуации англоязычное имя типа атрибута вполне оправдано наличием соответствующего базового типа в языках программирования. Абстрактный характер данного атрибута обозначается курсивным текстом в записи данного атрибута.</li>
  <li>форма:Многоугольник — здесь имя атрибута форма может характеризовать такой класс, который является геометрической фигурой на плоскости. В этом случае тип атрибута Многоугольник указывает на тот факт, что отдельная геометрическая фигура может иметь форму треугольника, прямоугольника, ромба, пятиугольника и любого другого многоугольника, но не окружности или эллипса. Вполне очевидно, что в данной ситуации использование соответствующего англоязычного термина вряд ли целесообразно, поскольку тип Многоугольник не является базовым для языков программирования.</li>
</ul>
<P>
Исходное значение служит для задания некоторого начального значения для соответствующего атрибута в момент создания отдельного экземпляра класса. Здесь необходимо придерживаться правила принадлежности значения типу конкретного атрибута. Если исходное значение не указано, то значение соответствующего атрибута не определено на момент создания нового экземпляра класса. С другой стороны, конструктор соответствующего объекта может переопределять исходное значение в процессе выполнения программы, если в этом возникает необходимость.
</P>
<P>
В качестве примеров исходных значений атрибутов можно привести следующие дополненные выше варианты задания атрибутов:
</P>
<ul>
  <li>цвет:Соlоr = (255, 0, 0) — в RGB-модели цвета это соответствует чистому красному цвету в качестве исходного значения для данного атрибута.</li>
  <li>имя_сотрудника[1..2]:String = Иван Иванович — возможно, это нетипичный случай, который, скорее, соответствует ситуации имя_руководителя[2]:81пп&sect; = Иван Иванович.</li>
  <li>видимость:Вооlеаn = истина — может соответствовать ситуации, когда в момент создания экземпляра класса создается видимое на экране монитора окно, соответствующее данному объекту.</li>
  <li>форма:Многоугольник = прямоугольник — вряд ли требует комментариев, поскольку здесь речь идет о геометрической форме создаваемого объекта.</li>
</ul>
<P>
При задании атрибутов могут быть использованы две дополнительные синтаксические конструкции — это подчеркивание строки атрибута и пояснительный текст в фигурных скобках.
</P>
<P>
Подчеркивание строки атрибута означает, что соответствующий атрибут может принимать подмножество значений из некоторой области значений атрибута, определяемой его типом. Эти значения можно рассматривать как набор однотипных записей или массив, которые в совокупности характеризуют каждый объект класса.
</P>
<P>
Например, если некоторый атрибут задан в виде <U>форма:
Прямоугольник.</U> то это будет означать, что все объекты данного класса могут иметь несколько различных форм, каждая из которых является прямоугольником. Другим примером может служить задание атрибута в виде
номер_счета:Integer. что может означать для объекта Сотрудник наличие некоторого подмножества счетов, общее количество которых заранее не фиксируется.
</P>
<P>
Строка-свойство служит для указания значений атрибута, которые не могут быть изменены в программе при работе с данным типом объектов. Фигурные скобки как раз и обозначают фиксированное значение соответствующего атрибута для класса в целом, которое должны принимать все вновь создаваемые экземпляры класса без исключения. Это значение принимается за исходное значение атрибута, которое не может быть переопределено в последующем. Отсутствие строки-свойства по умолчанию трактуется так, что значение соответствующего атрибута может быть изменено в программе. Например, строка-свойство в записи атрибута заработная_плата:Currency = = {$500} может служить для обозначения фиксированной заработной платы для каждого объекта класса &quot;Сотрудник&quot; определенной должности в некоторой организации. С другой стороны, запись данного атрибута в виде зара-ботная_плата: Currency = $500 означает уже нечто иное, а именно — при создании нового экземпляра Сотрудник (аналогия — прием на работу нового сотрудника) для него устанавливается по умолчанию заработная плата в $500. Однако для отдельных сотрудников могут быть сделаны исключения как в большую, так и в меньшую сторону, о чем необходимо позаботиться дополнительно в программе.
</P>
<p>&nbsp;
<a NAME="4"></a><font size="4">
Операция</font>
</P>
<P>
В третьей сверху секции прямоугольника записываются операции или методы класса. Операция (operation) представляет собой некоторый сервис, предоставляющий каждый экземпляр класса по определенному требованию. Совокупность операций характеризует функциональный аспект поведения
класса. Запись операций класса в языке UML также стандартизована и подчиняется определенным синтаксическим правилам. При этом каждой операции класса соответствует отдельная строка, которая состоит из квантора видимости операции, имени операции, выражения типа возвращаемого операцией значения и, возможно, строка-свойство данной операции:
</P>
<P>
&lt;квантор видимости&gt;&lt;имя операции&gt;(список параметров):
</P>
<P>
&lt;выражение типа возвращаемого значения&gt;{строка-свойство}
</P>
<P>
Квантор видимости, как и в случае атрибутов класса, может принимать одно из трех возможных значений и, соответственно, отображается при помощи специального символа. Символ &quot;+&quot; обозначает операцию с областью видимости типа общедоступный (public). Символ &quot;#&quot; обозначает операцию с областью видимости типа защищенный (protected). И, наконец, символ &quot;-&quot; используется для обозначения операции с областью видимости типа закрытый (private).
</P>
<P>
Квантор видимости для операции может быть опущен. В этом случае его отсутствие просто означает, что видимость операции не указывается. Вместо условных графических обозначений также можно записывать соответствующее ключевое слово:
public, protected, private.
</P>
<p><u><b><font color="#006600">Примечание</font></b></u></p>
<P>
<font color="#006600">
Применительно к конкретным языкам программирования могут быть определены дополнительные кванторы видимости. В этом случае подобные дополнения являются расширением базовой нотации и требуют соответствующих пояснений в форме текста на естественном языке или в виде строки-свойства.</font>
</P>
<P>
Имя операции представляет собой строку текста, которая используется в качестве идентификатора соответствующей операции и поэтому должна быть уникальной в пределах данного класса. Имя атрибута является единственным обязательным элементом синтаксического обозначения операции.
</P>
<P>
Список параметров является перечнем разделенных запятой формальных параметров, каждый из которых может быть представлен в следующем виде:
</P>
<P>
&lt;вид параметра&gt;&lt;имя параметра&gt;:&lt;выражение типа&gt;=&lt;значение параметра по
умолчанию&gt;.
</P>
<P>
Здесь вид параметра — есть одно из ключевых слов in, out или inout со значением in по умолчанию, в случае если вид параметра не указывается. Имя параметра есть идентификатор соответствующего формального параметра. Выражение типа является зависимой от конкретного языка программирования спецификацией типа возвращаемого значения для соответствующего формального параметра. Наконец, значение по умолчанию в общем случае представляет собой выражение для значения формального параметра, синтаксис которого зависит от конкретного языка программирования и подчиняется принятым в нем ограничениям.
</P>
<P>
Выражение типа возвращаемого значения также является зависимой от языка реализации спецификацией типа или типов значений параметров, которые возвращаются объектом после выполнения соответствующей операции. Двоеточие и выражение типа возвращаемого значения могут быть опущены, если операция не возвращает никакого значения. Для указания кратности возвращаемого значения данная спецификация может быть записана в виде списка отдельных выражений.
</P>
<P>
Строка-свойство служит для указания значений свойств, которые могут быть применены к данному элементу. Строка-свойство не является обязательной, она может отсутствовать, если никакие свойства не специфицированы.
</P>
<P>
Операция с областью действия на весь класс показывается подчеркиванием имени и строки выражения типа. По умолчанию под областью операции понимается объект класса. В этом случае имя и строка выражения типа операции не подчеркиваются.
</P>
<P>
Операция, которая не может изменять состояние системы и, соответственно, не имеет никакого побочного эффекта, обозначается строкой-свойством &quot;{запрос}&quot; (&quot;{query}&quot;). В противном случае операция может изменять состояние системы, хотя нет никаких гарантий, что она будет это делать.
</P>
<P>
Для повышения производительности системы одни операции могут выполняться параллельно или одновременно, а другие — только последовательно. В этом случае для указания параллельности выполнения операции используется строка-свойство вида &quot;{concurrency = имя}&quot;, где имя может принимать одно из следующих значений: последовательная (sequential), параллельная (concurrent), охраняемая (guarded). При этом придерживаются следующей семантики для данных значений:
</P>
<ul>
  <li>последовательная (sequential) — для данной операции необходимо обеспечить ее единственное выполнение в системе, одновременное выполнение других операций может привести к ошибкам или нарушениям целостности объектов класса.</li>
  <li>параллельная (concurrent) — данная операция в силу своих особенностей может выполняться параллельно с другими операциями в системе, при этом параллельность должна поддерживаться на уровне реализации модели.</li>
  <li>охраняемая (guarded) — все обращения к данной операции должны быть строго упорядочены во времени с целью сохранения целостности объектов данного класса, при этом могут быть приняты дополнительные меры по контролю исключительных ситуаций на этапе ее выполнения.</li>
</ul>
<P>
С целью сокращения обозначений допускается использование одного имени в качестве строки-свойства для указания соответствующего значения параллельности. Отсутствие данной строки-свойства означает, что семантика параллельности для операции не определена. Поэтому следует предположить худший с точки зрения производительности случай, когда данная операция требует последовательного выполнения.
</P>
<P>
Появление сигнатуры операции на самом верхнем уровне объявляет эту операцию на весь класс, при этом данная операция наследуется всеми потомками данного класса. Если в некотором классе операция не выполняется (т. е. некоторый метод не применяется), то такая операция может быть помечена как абстрактная &quot;{abstract}&quot;. Другой способ показать абстрактный характер операции — записать ее сигнатуру курсивом. Подчиненное появление записи данной операции без свойства {абстрактная} указывает на тот факт, что соответствующий класс-потомок может выполнять данную операцию в качестве своего &quot;метода.
</P>
<P>
Если для некоторой операции необходимо дополнительно указать особенности ее реализации (например, алгоритм), то это может быть сделано в форме примечания, записанного в виде текста, который присоединяется к записи операции в соответствующей секции класса. Если объекты класса принимают и реагируют на некоторый сигнал, то запись данной операции помечается ключевым словом &quot;сигнал&quot; (&quot;signal&quot;). Это обозначение равнозначно обозначению некоторой операции. Реакция объекта на прием сигнала может быть показана в виде некоторого автомата. Кроме других случаев эта нотация может быть использована, чтобы показать реакцию объектов класса на ошибочные ситуации или исключения, которые могут моделироваться как сигналы или сообщения.
</P>
<P>
Поведение операции может быть указано дополнительно в форме присоединенного к операции примечания. В этом случае текст примечания заключается в скобки, если он представляет собой формальную спецификацию на некотором языке программирования и соответствует элементу &quot;семантическое ограничение языка UML&quot;. В противном случае текст примечания является простым описанием на естественном языке и обозначается прямоугольником с &quot;загнутым&quot; верхним правым уголком (см. главу 4).
</P>
<P>
Список формальных параметров и тип возвращаемого значения могут не указываться. Квантор видимости атрибутов и операций может быть указан в виде специального значка или символа, которые используются для графического представления моделей в некотором инструментальном средстве. Имена операций, так же как и атрибутов, записываются со строчной (малой) буквы, а их типы — с заглавной (большой) буквы. При этом обязательной частью строки записи операции является наличие имени операции и круглых скобок.
</P>
<P>
В качестве примеров записи операций можно привести следующие обозначения отдельных операций:
</P>
<ul>
  <li>+создать() — может обозначать абстрактную операцию по созданию отдельного объекта класса, которая является общедоступной и не содержит формальных параметров. Эта операция не возвращает никакого значения после своего выполнения.</li>
  <li>+нарисовать(форма: Многоугольник = прямоугольник, цвет_заливки: Color = (О, О, 255)) — может обозначать операцию по изображению на экране монитора прямоугольной области синего цвета, если не указываются другие значения в качестве аргументов данной операции.</li>
  <li>запросить_счет_клиента(номер_счета:1п1е&sect;ег):Сиггепсу — обозначает операцию по установлению наличия средств на текущем счете клиента банка. При этом аргументом данной операции является номер счета клиента, который записывается в виде целого числа (например, &quot;123456&quot;). Результатом выполнения этой операции является некоторое число, записанное в принятом денежном формате (например, $1,500.00).</li>
  <li>выдать_сообщение():{&quot;Ошибка деления на ноль&quot;} — смысл данной операции не требует пояснения, поскольку содержится в строке-свойстве операции. Данное сообщение может появиться на экране монитора в случае попытки деления некоторого числа на ноль, что недопустимо.</li>
</ul>
<p>&nbsp;
<a NAME="5"></a><font size="4">
5.2. Отношения между классами</font>
</P>
<P>
Кроме внутреннего устройства или структуры классов на соответствующей диаграмме указываются различные отношения между классами. При этом совокупность типов таких отношений фиксирована в языке UML и предопределена семантикой этих типов отношений. Базовыми отношениями или связями в языке UML являются:
</P>
<ul>
  <li>Отношение зависимости (dependency relationship)</li>
  <li>Отношение ассоциации (association relationship)</li>
  <li>Отношение обобщения (generalization relationship)</li>
  <li>Отношение реализации (realization relationship)</li>
</ul>
<P>
Каждое из этих отношений имеет собственное графическое представление на диаграмме, которое отражает взаимосвязи между объектами соответствующих классов.
</P>
<p>&nbsp;
<a NAME="6"></a><font size="4">
Отношение зависимости</font>
</P>
<P>
Отношение зависимости в общем случае указывает некоторое семантическое отношение между двумя элементами модели или двумя множествами таких элементов, которое не является отношением ассоциации, обобщения или реализации. Оно касается только самих элементов модели и не требует множества отдельных примеров для пояснения своего смысла. Отношение зависимости используется в такой ситуации, когда некоторое изменение одного элемента модели может потребовать изменения другого зависимого от него элемента модели.
</P>
<P>
Отношение зависимости графически изображается пунктирной линией между соответствующими элементами со стрелкой на одном из ее концов (&quot;—&gt;&quot; или &quot;&lt;—&quot;). На диаграмме классов данное отношение связывает отдельные классы между собой, при этом стрелка направлена от класса-клиента зависимости к независимому классу или классу-источнику (рис. 5.3). На данном рисунке изображены два класса: Класс_А и Кяасс_Б, при этом Класс_Б является источником некоторой зависимости, а Класс_А — клиентом этой зависимости.
</P>
<IMG src="gl5-3.jpg">
<P>
<b>
Рис. 5.3.</b> Графическое изображение отношения зависимости на диаграмме классов
</P>
<P>
В качестве класса-клиента и класса-источника зависимости могут выступать целые множества элементов модели. В этом случае одна линия со стрелкой, выходящая от источника зависимости, расщепляется в некоторой точке на несколько отдельных линий, каждая из которых имеет отдельную стрелку для класса-клиента. Например, если функционирование Класса_С зависит от особенностей реализации Класса_А и Класса_/&gt;, то данная зависимость может быть изображена следующим образом (рис. 5.4).
</P>
<IMG src="gl5-4.jpg">
<P>
<b>
Рис. 5.4.</b> Графическое представление зависимости между классом-клиентом (Класс_С) и классами-источниками (Класс_Л и Класс_Б)
</P>
<P>
Стрелка может помечаться необязательным, но стандартным ключевым словом в кавычках и необязательным индивидуальным именем. Для отношения зависимости предопределены ключевые слова, которые обозначают некоторые специальные виды зависимостей. Эти ключевые слова (стереотипы) записываются в кавычках рядом со стрелкой, которая соответствует данной зависимости. Примеры стереотипов для отношения зависимости представлены ниже:
</P>
<ul>
  <li>&quot;access&quot; — служит для обозначения доступности открытых атрибутов и операций класса-источника для классов-клиентов;</li>
  <li>&quot;bind&quot; — класс-клиент может использовать некоторый шаблон для своей последующей параметризации;</li>
  <li>&quot;derive&quot; — атрибуты класса-клиента могут быть вычислены по атрибутам класса-источника;</li>
  <li>&quot;import&quot; — открытые атрибуты и операции класса-источника становятся частью класса-клиента, как если бы они были объявлены непосредственно в нем;</li>
  <li>&quot;refine&quot; — указывает, что класс-клиент служит уточнением класса-источника в силу причин исторического характера, когда появляется дополнительная информация в ходе работы над проектом.</li>
</ul>
<p><u><b><font color="#006600">Примечание</font></b></u></p>
<P>
<font color="#006600">
Отношение зависимости является наиболее общей формой отношения в языке UML. Все другие типы рассматриваемых отношений можно считать частным случаем данного отношения. Однако важность выделения специфических семантических свойств и дополнительных характеристик для других типов отношений обусловливают их самостоятельное рассмотрение при построении диаграмм.</font>
</P>
<p>&nbsp;
<a NAME="7"></a><font size="4">
Отношение ассоциации</font>
</P>
<P>
Отношение ассоциации соответствует наличию некоторого отношения между классами. Данное отношение обозначается сплошной линией с дополнительными специальными символами, которые характеризуют отдельные свойства конкретной ассоциации. В качестве дополнительных специальных символов могут использоваться имя ассоциации, а также имена и кратность классов-ролей ассоциации. Имя ассоциации является необязательным элементом ее обозначения. Если оно задано, то записывается с заглавной (большой) буквы рядом с линией соответствующей ассоциации.
</P>
<P>
Наиболее простой случай данного отношения — бинарная ассоциация. Она связывает в точности два класса и, как исключение, может связывать класс с самим собой. Для бинарной ассоциации на диаграмме может быть указан порядок следования классов с использованием треугольника в форме стрелки рядом с именем данной ассоциации. Направление этой стрелки указывает на порядок классов, один из которых является первым (со стороны треугольника), а другой — вторым (со стороны вершины треугольника). Отсутствие данной стрелки рядом с именем ассоциации означает, что порядок следования классов в рассматриваемом отношении не определен.
</P>
<P>
В качестве простого примера отношения бинарной ассоциации рассмотрим отношение между двумя классами — классом &quot;Компания&quot; и классом &quot;Сотрудник&quot; (рис. 5.5). Они связаны между собой бинарной ассоциацией Работа, имя которой указано на рисунке рядом с линией ассоциации. Для данного отношения определен порядок следования классов, первым из которых является класс &quot;Сотрудник&quot;, а вторым — класс &quot;Компания&quot;. Отдельным примером или экземпляром данного отношения может являться пара значений    (Петров    И. И.,    &quot;Рога&amp;Копыта&quot;).    Это    означает,    что    сотрудник Петров И. И. работает в компании &quot;Рога&amp;Копыта&quot;.
</P>
<IMG src="gl5-5.jpg">
<P>
<b>
Рис. 5.5.</b> Графическое изображение отношения бинарной ассоциации между классами
</P>
<P>
Тернарная ассоциация и ассоциации более высокой арности в общем случае называются N-арной ассоциацией (читается — &quot;эн арная ассоциация&quot;). Такая ассоциация связывает некоторым отношением 3 и более классов, при этом один класс может участвовать в ассоциации более чем один раз. Класс ассоциации имеет определенную роль в соответствующем отношении, что может быть явно указано на диаграмме. Каждый экземпляр N-арной ассоциации представляет собой N-арный кортеж значений объектов из соответствующих классов. Бинарная ассоциация является частным случаем N-арной ассоциации, когда значение N=2, и имеет свое собственное обозначение.
</P>
<P>
N-арная ассоциация графически обозначается ромбом, от которого ведут линии к символам классов данной ассоциации. В этом случае ромб соединяется с символами соответствующих классов сплошными линиями. Обычно линии проводятся от вершин ромба или от середины его сторон. Имя N-арной ассоциации записывается рядом с ромбом соответствующей ассоциации.
</P>
<P>
Порядок классов в N-арной ассоциации, в отличие от порядка множеств в отношении, на диаграмме не фиксируется. Некоторый класс может быть присоединен к ромбу пунктирной линией. Это означает, что данный класс обеспечивает поддержку свойств соответствующей N-арной ассоциации, а сама N-арная ассоциация имеет атрибуты, операции и/или ассоциации. Другими словами, такая ассоциация, в свою очередь, является классом с соответствующим обозначением в виде прямоугольника и является самостоятельным элементом языка UML — ассоциацией-классом (Association Class). N-арная ассоциация не может содержать символ агрегации ни для какой из своих ролей.
</P>
<P>
В качестве примера конкретной тернарной ассоциации рассмотрим отношение между тремя классами: &quot;Футбольная команда&quot;, &quot;Год&quot; и &quot;Игра&quot;. Данная ассоциация указывает на наличие отношения между этими тремя классами, которое может представлять информацию об играх футбольных команд в национальном чемпионате в течение нескольких последних лет (рис. 5.6).
</P>
<P>
Как уже упоминалось, отдельный класс ассоциации имеет собственную роль в отношении. Эта роль может быть изображена графически на диаграмме классов. С этой целью в языке UML вводится в рассмотрение специальный
элемент — конец ассоциации (Association End), который графически соответствует точке соединения линии ассоциации с отдельным классом. Конец ассоциации является частью ассоциации, но не класса. Каждая ассоциация имеет два или больше концов ассоциации. Наиболее важные свойства ассоциации указываются на диаграмме рядом с этими элементами ассоциации и должны перемешаться вместе с ними.
</P>
<IMG src="gl5-6.jpg">
<P>
<b>
Рис. 5.6.</b> Графическое изображение тернарной ассоциации между тремя классами
</P>
<P>
Одним из таких дополнительных обозначений является имя роли отдельного класса, входящего в ассоциацию. Имя роли представляет собой строку текста рядом с концом ассоциации для соответствующего класса. Она указывает специфическую роль, которую играет класс, являющийся концом рассматриваемой ассоциации. Имя роли не является обязательным элементом обозначений и может отсутствовать на диаграмме.
</P>
<P>
Следующий элемент обозначений — кратность отдельных классов, являющихся концами ассоциации. Кратность отдельного класса обозначается в виде интервала целых чисел, аналогично кратности атрибутов и операций классов. Интервал записывается рядом с концом ассоциации и для N-арной ассоциации означает потенциальное число отдельных экземпляров или значений кортежей этой ассоциации, которые могут иметь место, когда остальные N-1 экземпляров или значений классов фиксированы.
</P>
<P>
Так, для рассмотренного ранее примера (см. рис. 5.5) кратность &quot;1&quot; для класса &quot;Компания&quot; означает, что каждый сотрудник может работать только в одной компании. Кратность &quot;1..*&quot; для класса &quot;Сотрудник&quot; означает, что в каждой компании могут работать несколько сотрудников, общее число которых заранее неизвестно и ничем не ограничено. Заметим, что вместо кратности &quot;1..*&quot; записать только символ &quot;*&quot; нельзя, поскольку последний означает кратность &quot;0..*&quot;. Для данного примера это означало бы, что отдельные компании могут совсем не иметь сотрудников в своем штате. Но такая кратность вполне приемлема в других ситуациях, как это видно из рассмотренного выше примера (рис. 5.6).
</P>
<P>
Что касается других свойств отношения, ассоциации, то в случае их наличия, они могут рассматриваться в качестве атрибутов класса ассоциации и могут быть указаны на диаграмме обычным для класса способом в соответствующей секции прямоугольника класса.
</P>
<P>
Частным случаем отношения ассоциации является так называемая исключающая ассоциация (Xor-association). Семантика данной ассоциации указывает на тот факт, что из нескольких потенциально возможных вариантов данной ассоциации в каждый момент времени может использоваться только один ее экземпляр. На диаграмме классов исключающая ассоциация изображается пунктирной линией, соединяющей две и более ассоциации, рядом с которой записывается строка-ограничение &quot;{хог}&quot;.
</P>
<P>
Например, счет в банке может быть открыт для клиента, в качестве которого может выступать физическое лицо (индивидум) или компания, что изображается с помощью исключающей ассоциации (рис. 5.7).
</P>
<IMG src="gl5-7.jpg">
<P>
<b>
Рис. 5.7.</b> Графическое изображение исключающей ассоциации между тремя классами
</P>
<P>
Специальной формой или частным случаем отношения ассоциации является отношение агрегации, которое, в свою очередь, тоже имеет специальную форму — отношение композиции. Поскольку эти отношения имеют свои специальные обозначения и относятся к базовым понятиям языка UML, рассмотрим их последовательно.
</P>
<p>&nbsp;
<a NAME="8"></a><font size="4">
Отношение агрегации</font>
</P>
<P>
Отношение агрегации имеет место между несколькими классами в том случае, если один из классов представляет собой некоторую сущность, включающую в себя в качестве составных частей другие сущности.
</P>
<P>
Данное отношение имеет фундаментальное значение для описания структуры сложных систем, поскольку применяется для представления системных взаимосвязей типа &quot;часть-целое&quot;. Раскрывая внутреннюю структуру системы, отношение агрегации показывает, из каких компонентов состоит система и как они связаны между собой. С точки зрения модели отдельные части системы могут выступать как в виде элементов, так и в виде подсистем, которые, в свою очередь, тоже могут образовывать составные компоненты или подсистемы. Это отношение по своей сути описывает декомпозицию или разбиение сложной системы на более простые составные части, которые также могут быть подвергнуты декомпозиции, если в этом возникнет необходимость в последующем.
</P>
<p><u><b><font color="#006600">Примечание</font></b></u></p>
<P><font color="#006600">
В связи с рассмотрением данного отношения вполне уместно вспомнить о специальном термине &quot;агрегат&quot;, которое служит для обозначения технической
системы, состоящей из взаимодействующих составных частей или подсистем. Эта аналогия не случайна и может служить для более наглядного понимания сути рассматриваемого отношения.</font>
</P>
<P>
Очевидно, что рассматриваемое в таком аспекте деление системы на составные части представляет собой некоторую иерархию ее компонентов, однако данная иерархия принципиально отличается от иерархии, порождаемой отношением обобщения. Отличие заключается в том, что части системы никак не обязаны наследовать ее свойства и поведение, поскольку являются вполне самостоятельными сущностями. Более того, части целого обладают своими собственными атрибутами и операциями, которые существенно отличаются от атрибутов и операций целого.
</P>
<P>
В качестве примера отношения агрегации рассмотрим взаимосвязь типа &quot;часть-целое&quot;, которая имеет место между сущностью &quot;Грузовой автомобиль&quot; и такими компонентами, как &quot;Двигатель&quot;, &quot;Шасси&quot;, &quot;Кабина&quot;, &quot;Кузов&quot;. Не претендуя на точное соответствие терминологии данной предметной области, нетрудно представить себе, что грузовой автомобиль состоит из двигателя, шасси, кабины и кузова. Именно это отношение между классом &quot;Грузовой_автомобиль&quot; и классами &quot;Двигатель&quot;, &quot;Шасси&quot;, &quot;Кабина&quot;, &quot;Кузов&quot; описывает отношение агрегации.
</P>
<P>
Графически отношение агрегации изображается сплошной линией, один из концов которой представляет собой незакрашенный внутри ромб. Этот ромб указывает на тот из классов, который представляет собой &quot;целое&quot;. Остальные классы являются его &quot;частями&quot; (рис. 5.8).
</P>
<IMG src="gl5-8.jpg">
<P>
<b>
Рис. 5.8.</b> Графическое изображение отношения агрегации в языке UML
</P>
<P>
Еще одним примером отношения агрегации может служить известное каждому из читателей деление персонального компьютера на составные части: системный блок, монитор, клавиатуру и мышь. Используя обозначения языка UML, компонентный состав ПК можно представить в виде соответствующей диаграммы классов (рис. 5.9), которая в данном случае иллюстрирует отношение агрегации.
</P>
<IMG src="gl5-9.jpg"> &nbsp;
<P>
<b>
Рис. 5.9.</b> Диаграмма классов для иллюстрации отношения агрегации на примере ПК
</P>
<p>&nbsp;
<a NAME="9"></a><font size="4">
Отношение композиции</font>
</P>
<P>
Отношение композиции, как уже упоминалось ранее, является частным случаем отношения агрегации. Это отношение служит для выделения специальной формы отношения &quot;часть-целое&quot;, при которой составляющие части в некотором смысле находятся внутри целого. Специфика взаимосвязи между ними заключается в том, что части не могут выступать в отрыве от целого, т. е. с уничтожением целого уничтожаются и все его составные части.
</P>
<P>
Возможно, не самый лучший, но наверняка понятный всем пример этого отношения представляет собой живая клетка в биологии. Другой пример — окно интерфейса программы, которое может состоять из строки заголовка, кнопок управления размером, полос прокрутки, главного меню, рабочей области и строки состояния. Нетрудно понять, что подобное окно представляет собой класс, а его компоненты являются как классами, так и атрибутами или свойствами окна. Последнее обстоятельство весьма характерно для отношения композиции, поскольку отражает различные способы представления данного отношения.
</P>
<P>
Графически отношение композиции изображается сплошной линией, один из концов которой представляет собой закрашенный внутри ромб. Этот ромб указывает на тот из классов, который представляет собой класс-композицию или &quot;целое&quot;. Остальные классы являются его &quot;частями&quot; (рис. 5.10).
</P>
<IMG src="gl5-10.jpg"><br>
<b>Рис. 5.10.</b> Графическое изображение отношения композиции в языке UML
</P>
<P>
В качестве дополнительных обозначений для отношений композиции и агрегации могут использоваться дополнительные обозначения, применяемые для отношения ассоциации. А именно, указание кратности класса ассоциации и имени данной ассоциации, которые не являются обязательными. Применительно к описанному выше примеру класса &quot;Окно_программы&quot; его диаграмма классов может иметь следующий вид (рис. 5.11).
</P>
<IMG src="gl5-11.jpg">
<br>
<b>Рис. 5.11.</b> Диаграмма классов для иллюстрации отношения композиции на примере класса окна программы
</P>
<P>
Данный пример может иллюстрировать и другие особенности разрабатываемой компьютерной программы, которые не указывались в явном виде при описании этого примера Так, в частности, указание кратности 1 рядом с классом &quot;Рабочая_область&quot; характерно для однодокументных приложений.
</P>
<p>&nbsp;
<a NAME="10"></a><font size="4">
Отношение обобщения</font>
</P>
<P>
Отношение обобщения является обычным таксономическим отношением между более общим элементом (родителем или предком) и более частным или специальным элементом (дочерним или потомком). Данное отношение может использоваться для представления взаимосвязей между пакетами, классами, вариантами использования и другими элементами языка UML.
</P>
<P>
Применительно к диаграмме классов данное отношение описывает иерархическое строение классов и наследование их свойств и поведения. При этом предполагается, что класс-потомок обладает всеми свойствами и поведением класса-предка, а также имеет свои собственные свойства и поведение, которые отсутствуют у класса-предка. На диаграммах отношение обобщения обозначается сплошной линией с треугольной стрелкой на одном из концов (рис. 5.12). Стрелка указывает на более общий класс (класс-предок или суперкласс), а ее отсутствие — на более специальный класс (класс-потомок или подкласс).
</P>
<IMG src="gl5-12.jpg">
<P>
<b>
Рис. 5.12.</b> Графическое изображение отношения обобщения в языке UML
</P>
<P>
Как правило, на диаграмме может указываться несколько линий для одного отношения обобщения, что отражает его таксономический характер. В этом случае более общий класс разбивается на подклассы одним отношением Обобщения. Например, класс Геометрическая_фигура_на_плоскости (курсив обозначает абстрактный класс) может выступать в качестве суперкласса для подклассов, соответствующих конкретным геометрическим фигурам, таким как,Прямоугольник, Окружность, Эллипс и др. Данный факт может быть представлен графически в форме диаграммы классов следующего вида (рис. 5.13).
</P>
<IMG src="gl5-13.jpg">
<P>
<b>
Рис. 5.13.</b> Пример графического изображения отношения обобщения классов
</P>
<P>
С целью упрощения обозначений на диаграмме классов совокупность линий, обозначающих одно и то же отношение обобщения, может быть объединена в одну линию. В этом случае данные отдельные линии изображаются сходящимися к единственной .стрелке, имеющей с ними общую точку пересечения (рис. 5.14).
</P>
<IMG src="gl5-14.jpg">
<P>
<b>
Рис. 5.14.</b> Вариант графического изображения отношения обобщения классов для случая объединения отдельных линий
</P>
<P>
Это обозначение по форме соответствует графу специального вида, который рассматривался в главе 2, а именно — иерархическому дереву. В этом случае класс-предок является корнем этого дерева, а классы-потомки — его листьями. Отличие заключается в возможности указания на диаграмме классов потенциальной возможности наличия других классов-потомков, которые не включены в обозначения представленных на диаграмме классов (многоточие вместо прямоугольника).
</P>
<P>
Рядом со стрелкой обобщения может размещаться строка текста, указывающая на некоторые дополнительные свойства этого отношения. Данный текст будет относиться ко всем линиям обобщения, которые идут к классам-потомкам. Другими словами, отмеченное свойство касается всех подклассов данного отношения. При этом текст следует рассматривать как ограничение, и тогда он записывается в фигурных скобках.
</P>
<P>
В качестве ограничений могут быть использованы следующие ключевые слова языка UML:
</P>
<ul>
  <li>{complete} — означает, что в данном отношении обобщения специфицированы все классы-потомки, и других классов-потомков у данного класса-предка быть не может. Пример — класс Клиент_банка является предком для двух классов: Физическое_лицо и Компания, и других классов-потомков он не имеет. На соответствующей диаграмме классов это можно указать явно, записав рядом с линией обобщения данную строку-ограничение;</li>
  <li>{disjoint} — означает, что классы-потомки не могут содержать объектов, одновременно являющихся экземплярами двух или более классов. В приведенном выше примере это условие также выполняется, поскольку
предполагается, что никакое конкретное физическое лицо не может являться одновременно и конкретной компанией. В этом случае рядом с линией обобщения можно записать данную строку-ограничение;</li>
  <li>{incomplete} — означает случай, противоположный первому. А именно, предполагается, что на диаграмме указаны не все классы-потомки. В последующем возможно восполнить их перечень не изменяя уже построенную диаграмму. Пример — диаграмма класса &quot;Автомобиль&quot;, для которой указание всех без исключения моделей автомобилей соизмеримо с созданием соответствующего каталога. С другой стороны, для отдельной задачи, такой как разработка системы продажи автомобилей конкретных моделей, в этом нет необходимости. Но указать неполноту структуры классов-потомков все же следует;</li>
  <li>{overlapping} — означает, что отдельные экземпляры классов-потомков могут принадлежать одновременно нескольким классам. Пример — класс &quot;Многоугольник&quot; является классом-предком для класса &quot;Прямоугольник&quot; и класса &quot;Ромб&quot;. Однако существует отдельный класс &quot;Квадрат&quot;, экземпляры которого одновременно являются объектами первых двух классов. Вполне естественно такую ситуацию указать явно с помощью данной строки-ограничения.</li>
</ul>
<P>
С учетом возможности использования строк-ограничений диаграмма классов (рис. 5.14) может быть изображена без многоточий и без потери информации (рис. 5.15).
</P>
<IMG src="gl5-15.jpg">
<P>
<b>
Рис. 5.15.</b> Вариант графического изображения отношения обобщения классов с использованием строки-ограничения
</P>
<P>
Чтобы проиллюстрировать особенности использования отношения обобщения, преобразуем один из рассмотренных ранее примеров изображения классов в графическую нотацию языка UML. В качестве такого примера рассмотрим иерархию вложенности классов для абстрактного класса &quot;Автомобиль&quot; (см. рис. 1,2, 2.7). Как нетрудно заметить, отношение между отдельными классами на этих рисунках есть именно отношение обобщения, которое в языке UML имеет специальное графическое обозначение. С учетом этой графической нотации, фрагмент семантической сети для представления иерархии класса &quot;Автомобиль&quot; (см. рис. 2.7) может быть представлен в виде следующей диаграммы классов (рис. 5.16).
</P>
<P>
Заметим, что в данном примере все классы верхних уровней являются абстрактными, т. е. не могут быть представлены своими экземплярами. Именно поэтому их имена записаны курсивом. В отличие от них классы нижнего уровня являются конкретными, поскольку могут быть представлены своими экземплярами, в качестве которых выступают изготовленные автомобили соответствующей модели с уникальным заводским номером.
</P>
<IMG src="gl5-16.jpg">
<P>
<b>
Рис. 5.16.</b> Фрагмент диаграммы классов с отношением обобщения для представления иерархии классов &quot;Автомобиль&quot; из рассмотренного ранее примера (см. рис. 2.7)
</P>
<p><u><b><font color="#006600">Примечание</font></b></u></p>
<P>
<font color="#006600">
В качестве упражнения для закрепления рассмотренного материала можно попытаться построить диаграммы классов или хотя бы их фрагменты для библиотек стандартных классов MFC (Microsoft) и VCL (Borland/Inprise) с использованием графической нотации языка UML. Можно предположить, что в недалеком будущем справочные руководства по соответствующим средам программирования будут содержать именно такие диаграммы классов, а возможно, и некоторые другие.</font>
</P>
<p>&nbsp;
<a NAME="11"></a><font size="4">
5.3. Интерфейсы .</font>
</P>
<P>
Интерфейсы являются элементами диаграммы вариантов использования и были рассмотрены в главе 4. Однако при построении диаграммы классов отдельные интерфейсы могут уточняться и в этом случае для их изображения используется специальный графический символ — прямоугольник класса с ключевым словом или стереотипом &quot;interface&quot; (рис. 5.17). При этом секция атрибутов у прямоугольника отсутствует, а указывается только секция операций.
</P>
<IMG src="gl5-17.jpg">
<P>
<b>
Рис. 5.17.</b> Пример графического изображения интерфейса на диаграмме классов
</P>
<p>&nbsp;
<a NAME="12"></a><font size="4">
5.4. Объекты</font>
</P>
<P>
Объект (object) является отдельным экземпляром класса, который создается на этапе выполнения программы. Он имеет свое собственное имя и конкретные значения атрибутов. В силу самых различных причин может возникнуть необходимость показать взаимосвязи не только между классами модели, но и между отдельными объектами, реализующими эти классы. В данном случае может быть разработана диаграмма объектов, которая, хотя и не является канонической в метамодели языка UML, но имеет самостоятельное назначение.
</P>
<P>
Для графического изображения объектов используется такой же символ прямоугольника, что и для классов. Отличия проявляются при указании имен объектов, которые в случае объектов обязательно подчеркиваются (рис. 5.18). При этом запись имени объекта представляет собой строку текста <U>&quot;имя объекта:имя класса&quot;,</U> разделенную двоеточием (рис. 5.18 а, б). Имя объекта может отсутствовать, в этом случае предполагается, что объект является анонимным, и двоеточие указывает на данное обстоятельство (рис. 5.18, г). Отсутствовать может и имя класса. Тогда указывается просто имя объекта (рис. 5.18, в). Атрибуты объектов принимают конкретные значения.
</P>
<P>
При изображении диаграммы объектов нужно помнить, что каждый объект представляет собой экземпляр соответствующего класса, а отношения между объектами описываются с помощью связей (links), которые являются экземплярами соответствующих отношений. При этом все связи изображаются сплошными линиями. Более подробно особенности представления объектов будут рассмотрены в главе 9 при изучении диаграмм кооперации.
</P>
<IMG src="gl5-18.jpg">
<P>
<b>
Рис. 5.18.</b> Пример графического изображения объектов на диаграммах языка UML
</P>
<p>&nbsp;
<a NAME="13"></a><font size="4">
5.5. Шаблоны
или параметризованные классы</font>
</P>
<P>
Шаблон (template) или параметризованный класс (parametrized class) предназначен для обозначения такого класса, который имеет один (или более) нефиксированный формальный параметр. Он определяет целое семейство или множество классов, каждый из которых может быть получен связыванием этих параметров с действительными значениями. Обычно параметрами шаблонов служат типы атрибутов классов, такие как целые числа, перечисление, массив строк и др. В более сложном случае формальные параметры могут представлять и операции класса.
</P>
<P>
Графически шаблон изображается прямоугольником, к верхнему правому углу которого присоединен маленький прямоугольник из пунктирных линий (рис. 5.19), большой прямоугольник может быть разделен на секции, аналогично обозначению для класса. В верхнем прямоугольнике указывается список формальных параметров для тех классов, которые могут быть получены на основе данного шаблона. В верхней секции шаблона записывается его имя по правилам записи имен для классов.
</P>
<IMG src="gl5-19.jpg">
<P>
<b>
Рис. 5.19.</b> Графическое изображение шаблона на диаграмме классов
</P>
<P>
Шаблон не может быть непосредственно использован в качестве класса, поскольку содержит неопределенные параметры. Чаще всего в качестве шаблона выступает некоторый суперкласс, параметры которого уточняются в его классах-потомках. Очевидно, в этом случае между ними существует отношение зависимости с ключевым словом &quot;bind&quot;, когда класс-клиент может использовать некоторый шаблон для своей последующей параметризации. В более частном случае между шаблоном и формируемым от него классом имеет место отношение обобщения с наследованием свойств шаблона (рис. 5.20). В данном примере отмечен тот факт, что класс &quot;Адрес&quot; может быть получен из шаблона Связный_список на основе актуализации формальных параметров &quot;S, k, l&quot; фактическими атрибутами &quot;улица, дом, квартира&quot;.
</P>
<P>
Этот же шаблон может использоваться для задания (инстанцирования) другого класса, скажем, класса &quot;Точки_на_плоскости&quot;. В этом случае класс &quot;Точки_на_плоскости&quot; актуализирует те же формальные параметры, но
с другими значениями, например, &quot;ЬтсГ&lt;координаты_точки, х, у&gt;. Концепция шаблонов является достаточно мощным средством в ООП, и поэтому ее использование в языке UML позволяет не только сократить размеры диаграмм, но и наиболее корректно управлять наследованием свойств и поведения отдельных элементов модели.
</P>
<IMG src="gl5-20.jpg">
<P>
<b>Рис. 5.20.</b> Пример использования шаблона на диаграмме классов
</P>
<p>&nbsp;
<a NAME="14"></a><font size="4">
5.6. Рекомендации по построению диаграмм классов</font>
</P>
<P>
Процесс разработки диаграммы классов занимает центральное место в ООАП сложных систем. От умения правильно выбрать классы и установить между ними взаимосвязи часто зависит не только успех процесса проектирования, но и производительность выполнения программы. Как показывает практика ООП, каждый программист в своей работе стремится в той или иной степени использовать уже накопленный личный опыт при разработке новых проектов. Это обусловлено желанием свести новую задачу к уже решенным, чтобы иметь возможность использовать не только проверенные фрагменты программного кода, но и отдельные компоненты в целом (библиотеки компонентов).
</P>
<P>
Такой стереотипный подход позволяет существенно сократить сроки реализации проекта, однако приемлем лишь в том случае, когда новый проект концептуально и технологически не слишком отличается от предыдущих. В противном случае платой за сокращение сроков проекта может стать его реализация на устаревшей технологической базе. Что касается собственно объектной структуризации предметной области, то здесь уместно придерживаться тех рекомендаций, которые накоплены в ООП. Они широко освещены в литературе [1, 2, 4, 10, 13, 18, 20] и поэтому здесь не рассматриваются.
</P>
<P>
При определении классов, атрибутов и операций и задании их имен и типов перед отечественными разработчиками всегда встает невольный вопрос: какой из языков использовать в качестве естественного, русский или английский? С одной стороны, использование родного языка для описания модели является наиболее естественным способом ее представления и в наибольшей
степени отражает коммуникативную функцию модели системы. С другой стороны, разработка модели является лишь одним из этапов разработки соответствующей системы, а применение инструментальных средств для ее реализации в абсолютном большинстве случаев требует использования англоязычных терминов. Именно поэтому возникает характерная неоднозначность, с которой, по-видимому, совершенно незнакома англоязычная аудитория.
</P>
<P>
Отвечая на поставленный выше вопрос, следует отметить, что наиболее целесообразно придерживаться следующих рекомендаций. При построении диаграммы вариантов использования, являющейся наиболее общей концептуальной моделью проектируемой системы, применение русскоязычных терминов является не только оправданным с точки зрения описания структуры предметной области, но и эффективным с точки зрения коммуникативного взаимодействия с заказчиком и пользователями. При построении остальных типов диаграмм следует придерживаться разумного компромисса.
</P>
<P>
В частности, на начальных этапах разработки диаграмм целесообразность использования русскоязычных терминов вполне очевидна и оправдана. Однако, по мере готовности графической модели для реализации в виде программной системы и передачи ее для дальнейшей работы программистам, акцент может смещаться в сторону использования англоязычных терминов, которые в той или иной степени отражают особенности языка программирования, на котором предполагается реализация данной модели.
</P>
<P>
Более того, использование CASE-инструментариев для автоматизации ООАП, чаще всего, накладывает свои собственные требования на язык спецификации моделей. Именно по этой причине большинство примеров в литературе даются в англоязычном представлении, а при их переводе на русский может быть утрачена не только точность формулировок, но и семантика соответствующих понятий.
</P>
<P>
После разработки диаграммы классов процесс ООАП может быть продолжен в двух направлениях. С одной стороны, если поведение системы тривиально, то можно приступить к разработке диаграмм кооперации и компонентов. Однако для сложных динамических систем поведение представляет важнейший аспект их функционирования. Детализация поведения осуществляется последовательно при разработке диаграмм состояний, последовательности и деятельности. К изучению первой из них мы и приступим в главе 6.
</P>
<p><hr>
<table cellpadding=10>
<tr><td><a href=../../../index.htm>Каталог</a></td>
    <td><a href=../../index.htm>Индекс раздела</a></td>
    <td><a href=../index.html>Оглавление</a></td></tr>
</table>
</p>

</BODY>
</HTML>

